<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钟鼓楼</title>
  
  <subtitle>钟楼瘦，鼓楼胖</subtitle>
  <link href="https://thysrael.github.io/atom.xml" rel="self"/>
  
  <link href="https://thysrael.github.io/"/>
  <updated>2024-10-17T06:35:03.277Z</updated>
  <id>https://thysrael.github.io/</id>
  
  <author>
    <name>Thysrael</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并行计算-并行原语</title>
    <link href="https://thysrael.github.io/posts/cf617ad0/"/>
    <id>https://thysrael.github.io/posts/cf617ad0/</id>
    <published>2024-09-29T08:42:45.000Z</published>
    <updated>2024-10-17T06:35:03.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><p>在并行编程中，除了“互斥”这个原语外（一般是采用“锁”来实现），还存在“同步（synchronous）”这个原语，这个原语指的是“各个事件按照特定顺序执行”的需求。比如说在生产者消费者模型中，必须要让生产者先生产，消费者才可以进行消费，这就是一种同步行为，是没有办法仅仅依靠锁来实现的。</p><p>当涉及互斥时，涉及到的术语是 <code>lock, unlock, mutex</code> ，而涉及到同步是术语是 <code>wait, signal, notify, barrier</code> 等。之前我只重视了互斥的学习，而对于同步语义，则非常忽视。</p><hr><h2 id="二、互斥"><a href="#二、互斥" class="headerlink" title="二、互斥"></a>二、互斥</h2><p>上锁是维护互斥性的方式，只有拿到锁的线程，可以访问关键区域。</p><h3 id="2-1-自旋锁"><a href="#2-1-自旋锁" class="headerlink" title="2.1 自旋锁"></a>2.1 自旋锁</h3><p>自旋锁（Spinlock）是最为朴素的锁，它的形式是这样的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test lock</span>condition <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// lock</span><span class="token comment">// do some critical thing...</span>condition <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// unlock</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要不满足 <code>condition</code>，那么就会一直停留在 <code>while</code> 语句中执行。所谓的“自旋”，指的就是“自我重复循环”的意思。</p><h3 id="2-2-互斥锁"><a href="#2-2-互斥锁" class="headerlink" title="2.2 互斥锁"></a>2.2 互斥锁</h3><p>互斥锁（mutex，mutual exclusive）的形式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test lock</span>condition <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// lock</span><span class="token comment">// do some critical thing...</span>condition <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// unlock</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一旦条件检验不通过，自旋锁会立刻进行下一次条件检验，而互斥锁则会 <code>yield</code>，将执行权让给其他线程。自旋锁的设计，是在自旋的过程中依然占据资源，其优势在于并不会引入额外的上下文切换开销，当自旋时间不多的时候（也就是关键区比较短），那么用自旋锁比较合适。而如果关键区比较长，切换上下文开销小于资源占用的开销，那么就用互斥锁更为合适。</p><h3 id="2-3-CAS"><a href="#2-3-CAS" class="headerlink" title="2.3 CAS"></a>2.3 CAS</h3><p>上述的锁的实现都是“伪代码”，如果是 C 代码的话，是会存在问题的。考虑这样一个情形，此时有 A 和 B 都在等待 <code>condition</code> 发生变化，一旦 <code>condition</code> 变成 <code>true</code>，A 从 <code>while</code> 中离开，然后在“ A 设置 <code>condition = false</code> 来阻止其他的线程访问”这个时刻之前，突然调度器将 A 挂起，将 B 执行，此时 <code>conditon</code> 已然是 <code>true</code>，所以 B 也可以进入关键区，此时有两个线程在关键区，那么就发生了错误。</p><p>从上述描述中可以看出，发生错误的核心在于“检测 condition”和“设置 condition”这两个行为是没有绑定在一起的，一旦上下文切换发生在二者之间，就会导致发生错误。我们可以在硬件层面上将这两个行为统一成一个“原子行为”，一个常见的实现就是 CAS（Compare And Swap），其伪代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">CompareAndSwap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> expected<span class="token punctuation">,</span> <span class="token keyword">int</span> new<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>old <span class="token operator">==</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>ptr <span class="token operator">=</span> new<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> old<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个行为基本上就是检验旧值是否符合预期，如果符合预期就将旧值修改为新值，否则保持不变。此时就可以轻易实现一个自旋锁：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">CompareAndSwap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>condition<span class="token punctuation">,</span> true<span class="token punctuation">,</span> false<span class="token punctuation">)</span> <span class="token operator">==</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>  lock<span class="token operator">-&gt;</span>condition <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>突然想起来，<code>lock/unlock</code> 之间的关键区，也可以看作是原子性的，没有任何其他的指令可以插手这个区域。锁机制可以看作是对 CAS 原子性的一种拓展，原先只有一条指令是原子性的，现在是一个区域内的所有指令都是原子性的了。</p><p>我们设计关键区的时候，除了“共享”外，还可以从“不被打断”的角度去设计。 </p><hr><h2 id="三、同步"><a href="#三、同步" class="headerlink" title="三、同步"></a>三、同步</h2><h3 id="3-1-条件变量"><a href="#3-1-条件变量" class="headerlink" title="3.1 条件变量"></a>3.1 条件变量</h3><p>可以看到上述描述的互斥原语和锁机制，往往是发生在身份相同的线程中的，它们往往执行同一段代码，履行相同的职责，所以需要互斥机制来保证独立性。不过线程并不只有“竞争者”这一个身份，还有可能是”协作者“，此时他们就需要”同步“机制来确保他们的协同性。</p><p>同步机制比较简单的一个版本就是“先 <code>2</code> 后 <code>1</code>”，其中 <code>1</code> 和 <code>2</code> 是两个不同的线程，如果仅有锁机制，我们没法保证执行的顺序问题。但是如果当 <code>1</code> 先执行的时候，让它先 <code>wait</code> 一下 <code>2</code> ，直到 <code>2</code> 执行完了以后 <code>signal</code> 提醒一下它，它再加入就绪队列。其中 <code>1</code> 的“等待室”，就被称为条件变量（Condition Variable）。</p><p>基于这种思想，我们有了第一版代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span>；<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意此时的 <code>cond_wait</code> 和 mutex 的 <code>yield</code> 不同，<code>yield</code> 是将线程加入到 OS 的待调度队列中，如果队列中没有其他线程了，那么等待锁的线程还是会反复被调用，而 <code>cond_wait</code> 是一个独立的等待队列，如果不被 <code>signal/notify</code> ，那么就永远不会被调度。这就导致在同步的应用中，常常出现有些线程在等待室里“醒不过来”的情况。</p><p>然后我们就会发现一个问题，就是如果 <code>2</code> 先执行完成呢？那么 <code>1</code> 就会一直 <code>wait</code> 下去，因为 <code>signal</code> 信号早就执行完了，这个问题被称为“唤醒丢失”。让我们再回顾需求，会发现其实 <code>1</code> 只有在 <code>2</code> 还没有执行的时候，才需要 <code>wait</code> ，如果本来就是 <code>2</code> 先执行，那么就无须 <code>wait</code> 了，我们可以用一个共享变量来指示是否线程 <code>1</code> 已经执行完了，于是我们得到了第二版：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>condition <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这就有一个问题，就是 <code>condition</code> 作为共享变量，有可能出现“共同访问”的问题，比如先调度 <code>1</code> 时完成了对于 <code>condition == 0</code> 的检查，然后切换到了 <code>2</code>，并完成了 <code>signal</code>，然后再切换到 <code>1</code> 来执行 <code>wait</code>，那么就收不到信号了。那么此时就需要用锁来实现原子性，要保证对 <code>condition</code> 的访问和 <code>wait/signal</code> 是绑定在一起的，于是我们得到了第三版：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pthread_cond_t</span> cond<span class="token punctuation">;</span><span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span><span class="token keyword">int</span> condition <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>condition <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此可见即使在原本的实际中并不涉及共享内存（<code>1</code> 和 <code>2</code> 都只打印信息，并不访问共享内存），仅是处于同步的需求，条件变量也必须要和锁紧密配合。这就是在 POSIX 的条件变量的 API 中有锁的原因。</p><p>上述简单的例子已经结束了，但是条件变量依然还存在一个问题，也就是“虚假唤醒”。这个问题涉及到了条件变量的实现机制，线程在 <code>wait</code> 的时候，会将锁释放掉，当被其他线程 <code>signal</code> 的时候，它不是立刻执行，而是被放到了 OS 的待调度队列中，当调度到他的时候，他要再去拿锁然后执行，如果没有拿到锁，那么还会被重新插入到 OS 的待调度队列中等待（相当于隐式 <code>yield</code> 了）。</p><p>这种机制就存在一个问题了，就是在线程被 <code>signal</code> 唤醒后插入到待调度队列中，到真正拿到锁开始执行的这段时间内，有可能有其他线程修改了 <code>condition</code> 这样的条件，致使从语义上来说，线程应该继续 <code>wait</code>，而因为 <code>if</code> 的原因，使得线程逃离 <code>wait</code>，开始执行。所以我们最后要做的修改就是将 <code>if</code> 改成 <code>while</code>，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>condition <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个意义上来看，所谓的“signal 唤醒”，对于被唤醒的进程，并不能保证现在的唤醒符合“可执行”的条件了，而只是“可能可执行”，需要进一步的检查。</p><h3 id="3-2-信号量"><a href="#3-2-信号量" class="headerlink" title="3.2 信号量"></a>3.2 信号量</h3><p>不可否认，条件变量是丑陋的，他必须配合锁，而且还要搭配 <code>while</code> 才能使用。究其根本，是因为它具有“唤醒丢失”和“虚假唤醒”的问题。</p><p>“唤醒丢失”是因为条件变量本身不具有状态导致的，必须用一个共享变量来指导同步，如果我们将一个共享变量封装到其中呢？那我们是不是就不用显式的面对锁的问题了。而反正我们都将共享变量封装到其中了，与之相关的控制语句 <code>while</code> 也封装进去，也不是什么困难的事情了。于是我们就得到了信号量（Semaphore）。</p><p>信号量的本质是一个计数器 counter，它具有 <code>P</code> （<code>wait</code>）和 <code>V</code> （<code>post</code>）两种操作，<code>P</code> 会减少 counter 的值，如果 <code>counter == 0</code>，那么就会让发起 <code>P</code> 操作的线程进入“等待室”；<code>V</code> 会增加 counter 的值，如果 <code>counter &gt; 0</code>，那么就会唤醒等待室中的线程。</p><p>可以看到基本上信号量就是将原本的 <code>condition</code> 转换成了 <code>counter</code> 并封装进了自身内部。其实现如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">sem_wait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">CompareAndSwap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">/* 该线程进入 s.quene 队列 */</span>                <span class="token comment">/* 阻塞该线程（还需将 s.flag 设置为 0，阻塞和赋值需要是一个原子操作） */</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">sem_post</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">CompareAndSwap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">/* 从s.queue 队列中移出线程 p */</span>                <span class="token comment">/* 线程 p 进入就绪队列 */</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>信号量是 System V 提出的机制，它足够强大，以至于仅凭这一个机制，就可以实现互斥和同步两种原语。</p><p>当信号量初始值为 <code>1</code> 的时候，他可以用作互斥，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">sem_t</span> m<span class="token punctuation">;</span><span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 临界区</span><span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">sem_t</span> m<span class="token punctuation">;</span><span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 临界区</span><span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而当信号量初始值为 <code>0</code> 时，可以用于同步，这是因为此时就必须先 <code>post</code> 后 <code>wait</code> 才可以避免阻塞：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am f2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到信号量非常简洁美妙。</p><hr><h2 id="四、生产者消费者模型"><a href="#四、生产者消费者模型" class="headerlink" title="四、生产者消费者模型"></a>四、生产者消费者模型</h2><p>生产者消费者模型是非常经典的并行原语的应用。其中因为生产者和消费者会同时访问同一片共享区域，需要使用互斥机制；又因为当消费品为零或者满的时候，需要使消费者或者生产者 <code>wait</code> ，当条件满足时，又需要 <code>signal</code> 生产者和消费者，所以需要同步机制。</p><p>并不是所有的共享同一片内存，具有读写两方的模型都被叫作生产者消费者模型，生产者和消费者之间必须有同步机制来提高效率，这样才能叫作生产者消费者机制。同步机制是非常重要的，考虑生产者的效率是消费者的十倍，那么生产者必然很快就会填满缓冲区，随后生产者会重复拿锁进入缓冲区，并不干任何事情就离开，而消费者不容易拿到锁，机会被大量挤占，导致消费能力进一步降低。而有了同步机制，当产品填满缓冲区时，生产者就可以 <code>wait</code> 等待消费者唤醒了，这样更加高效。</p><p>生产者消费者模型有“阻塞队列”和“循环队列”两种形式，分别对应条件变量和信号量实现。循环队列的方式更优，因为阻塞队列是用一把锁保护整个共享区域，而实际上只要不是同时对于同一个商品读写，那么其实共享区域是允许同时存在一个生产者和一个消费者的，循环队列配合信号量可以很容易解决这个问题。</p><p>更加具体的描述和实现，可以在<a href="https://cloud.tencent.com/developer/article/2352249">这里</a>找到。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、总论&quot;&gt;&lt;a href=&quot;#一、总论&quot; class=&quot;headerlink&quot; title=&quot;一、总论&quot;&gt;&lt;/a&gt;一、总论&lt;/h2&gt;&lt;p&gt;在并行编程中，除了“互斥”这个原语外（一般是采用“锁”来实现），还存在“同步（synchronous）”这个原语，这个原语指的是“各个事件按照特定顺序执行”的需求。比如说在生产者消费者模型中，必须要让生产者先生产，消费者才可以进行消费，这就是一种同步行为，是没有办法仅仅依靠锁来实现的。&lt;/p&gt;
&lt;p&gt;当涉及互斥时，涉及到的术语是 &lt;code&gt;lock, unlock, mutex&lt;/code&gt; ，而涉及到同步是术语是 &lt;code&gt;wait, signal, notify, barrier&lt;/code&gt; 等。之前我只重视了互斥的学习，而对于同步语义，则非常忽视。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二、互斥&quot;&gt;&lt;a href=&quot;#二、互斥&quot; class=&quot;headerlink&quot; title=&quot;二、互斥&quot;&gt;&lt;/a&gt;二、互斥&lt;/h2&gt;</summary>
    
    
    
    <category term="并行计算" scheme="https://thysrael.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="并行计算" scheme="https://thysrael.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="S9课上" scheme="https://thysrael.github.io/tags/S9%E8%AF%BE%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>海边拾贝-ExtMem</title>
    <link href="https://thysrael.github.io/posts/cbf91d56/"/>
    <id>https://thysrael.github.io/posts/cbf91d56/</id>
    <published>2024-08-26T12:31:23.000Z</published>
    <updated>2024-10-17T06:35:03.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文提出了一种用户态缺页异常处理框架，可以轻松适配不同的处理策略，适用于高并发环境。其亮点在于：</p><ul><li>框架的易用性：<ul><li>基于 Linux 的 Semi-Microkernel 设计</li><li>透明</li></ul></li><li>性能：<ul><li>采用了微内核和外核思想中的 upcall 设计</li><li>采用了先进的异步批处理 IO 后端 io_ring</li></ul></li></ul></blockquote><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><h3 id="1-1-特化内存管理"><a href="#1-1-特化内存管理" class="headerlink" title="1.1 特化内存管理"></a>1.1 特化内存管理</h3><p>从软件层去看，目前内存密集型应用越来越多，如 TB 级的机器学习、大型图计算，内存数据库等。从硬件层去看，硬件新特性有很多，比如分离式内存、分层内存等。这些新的变化都对内存管理策略提出了新的挑战。</p><p>通用操作系统的内存管理策略并不适用于内存密集型应用，也不能针对性的利用硬件新特性。有研究表明最大的系统瓶颈是内存管理而不是设备带宽。</p><p>特化的内存管理策略（offload，prefetch，swap policy…）可以大大缓解这一现象。但是<strong>特化策略的普适性并不好</strong>。</p><h3 id="1-2-内核态内存管理"><a href="#1-2-内核态内存管理" class="headerlink" title="1.2 内核态内存管理"></a>1.2 内核态内存管理</h3><p>因为 Linux 内存管理模块十分基础、关键和复杂，所以在内核中开发、测试和部署一个新的内存管理策略开销非常大。大约 20 行代码即可描述的算法需要修改 20 个文件；测试开发需要 17 个月（和前面的不是同一个例子）；即使做出了，也很难被内核社区所接纳。</p><h3 id="1-3-用户内存管理框架"><a href="#1-3-用户内存管理框架" class="headerlink" title="1.3 用户内存管理框架"></a>1.3 用户内存管理框架</h3><p>“特化内存管理策略的有效性、不普适性和内核态内存策略的高昂开销”都在呼唤一个用户态的内存管理框架，也就是可以为多种内存管理策略提供支持的基础设施。</p><p>Linux 提供了 userfaultfd 机制来作为管理框架，用户基于此来实现用户态内存管理策略。框架的实现可以看作在进程中存在一个 manager thread，当一个 thread 发生 page fault 的时候，会通过基于 fd 的 IPC 方式（类似管道）给 manager thread 发信息报告自己缺失的地址等信息，manager thread 会根据相关信息进行处理。</p><p>本文认为这种方式并不适合高并发环境，采用 upcall 的方式和 ExoKernel 的理念去实现框架。</p><hr><h2 id="二、设计"><a href="#二、设计" class="headerlink" title="二、设计"></a>二、设计</h2><h3 id="2-1-upcall"><a href="#2-1-upcall" class="headerlink" title="2.1 upcall"></a>2.1 upcall</h3><p>Upcall 指的是从内核调用用户函数，可以看作是一种反向 syscall，常见于微内核系统，比如 chcore 中的 thread migration 机制。</p><p>传统的 userfaultfd 在高并发环境下存在延迟问题，这主要是由两方面原因组成：</p><p>一方面，线程的调度和切换开销很大，userfaultfd 下的 fault thread 和 MM thread 之间可能会插入多个其他无关线程（灰色虚线部分）：</p><p><img src="/posts/cbf91d56/userfaultsd.drawio.png" alt="userfaultsd.drawio"></p><p>而 upcall 可以由内核指定 MM thread 运行，并不需要调度：</p><p><img src="/posts/cbf91d56/extmem.drawio.png" alt="extmem.drawio"></p><p>另一方面，userfaultfd 的 MM thread 会串行处理 page fault，当多个线程都发生 page fault 的时候，会有排队现象：</p><p><img src="/posts/cbf91d56/userfaultfd1.drawio.png" alt="userfaultfd1.drawio"></p><p>但是利用 upcall 可以构造出 self-paging 机制，即 page fault handler 的本质是一个每个进程都有的库函数，发生 page fault 后内核会 upcall 进程自己的 handler 函数，这样多个 page fault handle 就可以并行了：</p><p><img src="/posts/cbf91d56/extmem2.drawio.png" alt="extmem2.drawio"></p><h3 id="2-2-io-uring"><a href="#2-2-io-uring" class="headerlink" title="2.2 io_uring"></a>2.2 io_uring</h3><p>内存管理可以分成前后端：前端负责处理 page fault 请求，分配页面完成映射；后端负责设备 I/O。</p><p>ExtMem 对于后端只要求 Direct I/O（也就是绕过 Linux 系统的 page cache），并没有对后端的同步和异步做出限制，ExtMem 自己使用了最为先进的 io_uring 机制。</p><p>之所以要强调这一点，是因为在后面的测试中，采用相同策略的 Linux 内核和 ExtMem 相对比，ExtMem 更占优势，它给出的解释是 ExtMem 在 evict 的代码更少，但是我觉得可能 io_uring 也发挥了一定的作用。</p><p>总得来说，io_uring 是 Linux 提供的一个先进的，异步的，非常适合批处理的 IO 接口：</p><p><img src="/posts/cbf91d56/io_uring.png" alt="img"></p><p>Linux 内部的 IO 使用的是中断驱动模式（应该是，不保真），而 io_uring 可以使用轮询模式。在高性能设备上，IO 的开销是小于上下文切换的开销的，所以轮询模式更优。</p><p><img src="/posts/cbf91d56/benchmark-1-1724747043453-9.png" alt="img"></p><hr><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="3-1-三层设计"><a href="#3-1-三层设计" class="headerlink" title="3.1 三层设计"></a>3.1 三层设计</h3><p>在设计上，该框架分为 3 层：</p><ul><li>core：和内核交互，实现监视虚拟地址，完成映射，IO 等基础功能</li><li>observability：提供对内存“冷热”等属性的信息</li><li>policy：提供实现具体策略所需要的 API。</li></ul><h3 id="3-2-链接与拦截"><a href="#3-2-链接与拦截" class="headerlink" title="3.2 链接与拦截"></a>3.2 链接与拦截</h3><p>为了用户的透明性（只 <code>mmap()</code> 等内存管理函数不需要修改），ExtMem 通过改变链接器的 <code>LD_PRELOAD</code> 变量实现了对于原有库函数的覆盖，通过使用 Intel libsyscall_intercept 技术实现了对于系统调用的覆盖。</p><h3 id="3-3-改写-UserFaultFD，SIGBUS"><a href="#3-3-改写-UserFaultFD，SIGBUS" class="headerlink" title="3.3 改写 UserFaultFD，SIGBUS"></a>3.3 改写 UserFaultFD，SIGBUS</h3><p>upcall 并不是 Linux 的原生机制，所以需要修改 Linux 内核支持 upcall：</p><p>一方面，ExtMem 复用了 Linux 信号机制中的 SIGBUS 信号，因为信号机制可以看作内核调用用户 handler，和 upcall 的语义近似。但是信号对于 handler 可重入性和线程安全的要求较高，为了功能的正常高效运行，ExtMem 削弱了一些原本的约束。</p><p>一方面，ExtMem 修改了 userfaultfd，使其不再通过基于 fd  的 IPC 通信，而是通过信号通信。</p><hr><h2 id="四、评估"><a href="#四、评估" class="headerlink" title="四、评估"></a>四、评估</h2><h3 id="4-1-评估环境"><a href="#4-1-评估环境" class="headerlink" title="4.1 评估环境"></a>4.1 评估环境</h3><p>如表所示：</p><div class="table-container"><table><thead><tr><th>条目</th><th>数据</th></tr></thead><tbody><tr><td>CPU</td><td>2.30GHz 的 Intel Xeon 5218 处理器</td></tr><tr><td>核心</td><td>16 个核心，每个核心 32 个硬件线程</td></tr><tr><td>内存</td><td>198GB 的 DDR4 内存</td></tr><tr><td>外存</td><td>读取速率为 2700 MB/s 的 NVMe SSD</td></tr><tr><td>操作系统</td><td>Linux 5.15</td></tr></tbody></table></div><h3 id="4-2-单次延迟"><a href="#4-2-单次延迟" class="headerlink" title="4.2 单次延迟"></a>4.2 单次延迟</h3><p>处理单个 page fault 的延迟如下：</p><p><img src="/posts/cbf91d56/image-20240827164626572.png" alt="image-20240827164626572"></p><p>其中 Upcall 指的是进行过性能优化的 SIGBUS 方法。</p><p>可以看到 UFFD 的方式在高并发环境下表现不良。而 ExtMem 则更好。</p><h3 id="4-3-相同策略吞吐"><a href="#4-3-相同策略吞吐" class="headerlink" title="4.3 相同策略吞吐"></a>4.3 相同策略吞吐</h3><p>他们在 ExtMem 上实现了和 Linux 相同的 2Q-LRU 逐出策略并进行测试。</p><p>使用 <code>mmap</code>  microbenchmark 去测试吞吐量，将 RAM 限制到 8G 来触发 page fault。</p><p>它测试了随机访存和顺序访存两种 pattern 下的吞吐</p><p><img src="/posts/cbf91d56/image-20240827165459110.png" alt="image-20240827165459110"></p><p>可以看到 ExtMem 都是优于 Linux，它论文中解释原因为 evict 的代码更简洁：</p><blockquote><p>The EXTMEM implementation evicts pages more quickly than Linux does, because its eviction code path is simpler, thereby explaining its performance advantage</p></blockquote><h3 id="4-4-预取"><a href="#4-4-预取" class="headerlink" title="4.4 预取"></a>4.4 预取</h3><p>在使用了预取策略后，我们评估 ExtMem 保留工作集的能力：</p><p><img src="/posts/cbf91d56/image-20240827170114740.png" alt="image-20240827170114740"></p><h3 id="4-5-CSR"><a href="#4-5-CSR" class="headerlink" title="4.5 CSR"></a>4.5 CSR</h3><p>压缩稀疏行（Compressed Sparse Row，CSR）是一种广泛用于内存图分析的数据结构。为使用 CSR 的应用开发一种新的内存管理策略：”将关键数据尽可能保存在内存中，并且利用一个滑动窗口的思想来指导数据的读入和逐出“，被称为 ”PR“。</p><p>运行 Twitter dataset using GAP benchmark suite 效果对比如下：</p><p><img src="/posts/cbf91d56/image-20240827170458158.png" alt="image-20240827170458158"></p><hr><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文设计了一个用户态的内存管理策略框架，采用 upcall 机制来优化其在高并发环境下的表现，并且使用了一些工程技术来使得这个框架的易用性很好。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文提出了一种用户态缺页异常处理框架，可以轻松适配不同的处理策略，适用于高并发环境。其亮点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架的易用性：&lt;ul&gt;
&lt;li&gt;基于 Linux 的 Semi-Microkernel 设计&lt;/li&gt;
&lt;li&gt;透明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能：&lt;ul&gt;
&lt;li&gt;采用了微内核和外核思想中的 upcall 设计&lt;/li&gt;
&lt;li&gt;采用了先进的异步批处理 IO 后端 io_ring&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;h3 id=&quot;1-1-特化内存管理&quot;&gt;&lt;a href=&quot;#1-1-特化内存管理&quot; class=&quot;headerlink&quot; title=&quot;1.1 特化内存管理&quot;&gt;&lt;/a&gt;1.1 特化内存管理&lt;/h3&gt;&lt;p&gt;从软件层去看，目前内存密集型应用越来越多，如 TB 级的机器学习、大型图计算，内存数据库等。从硬件层去看，硬件新特性有很多，比如分离式内存、分层内存等。这些新的变化都对内存管理策略提出了新的挑战。&lt;/p&gt;
&lt;p&gt;通用操作系统的内存管理策略并不适用于内存密集型应用，也不能针对性的利用硬件新特性。有研究表明最大的系统瓶颈是内存管理而不是设备带宽。&lt;/p&gt;</summary>
    
    
    
    <category term="海边拾贝" scheme="https://thysrael.github.io/categories/%E6%B5%B7%E8%BE%B9%E6%8B%BE%E8%B4%9D/"/>
    
    
    <category term="知识总结" scheme="https://thysrael.github.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    <category term="S8假期" scheme="https://thysrael.github.io/tags/S8%E5%81%87%E6%9C%9F/"/>
    
    <category term="海边拾贝" scheme="https://thysrael.github.io/tags/%E6%B5%B7%E8%BE%B9%E6%8B%BE%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>面向对象-设计模式</title>
    <link href="https://thysrael.github.io/posts/94e7864c/"/>
    <id>https://thysrael.github.io/posts/94e7864c/</id>
    <published>2024-08-22T06:29:00.000Z</published>
    <updated>2024-10-17T06:35:03.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><p>设计模式是一个工程问题，它不能为某个问题提供具体的答案，它只能让答案写得好看一些。</p><p>更进一步地说，设计模式是用于解决代码复杂度高（不是算法复杂度）的问题，这会引发难以阅读，难以维护等伴生问题。当代码量小，复杂度低，没有什么维护需求的时候（比如说科研代码），其实是没有必要采用规范的设计模式的。</p><p>我个人学习设计模式，并不是为了写代码（因为我写的代码就是科研代码），而是为了更好的阅读代码，因为大型工程代码都会或多或少遵循设计模式的思路。</p><p>很多设计模式解决的复杂度问题，是客观存在的，认识这些问题有助于设计出更加简洁健壮的架构；但是有些问题可能只是类似 Java 等语言表述能力不够所导致的，不用太较真。</p><hr><h2 id="二、设计原则"><a href="#二、设计原则" class="headerlink" title="二、设计原则"></a>二、设计原则</h2><p>设计原则的目的同样是降低代码的复杂度。它可以看作是设计模式的“基本原理”，每个设计模式都或多或少贯彻了这些原则。</p><p>我们会介绍一些这些原则的具体内容，并简单描述一下这些原则是如何发挥作用的。总的来说，它们都是在描述“一个好的抽象”或者说“一个好的接口”，应该具有哪些性质（简洁、稳定、精妙、短小）。</p><h3 id="2-1-单一职责原则"><a href="#2-1-单一职责原则" class="headerlink" title="2.1 单一职责原则"></a>2.1 单一职责原则</h3><p>单一职责原则（Single Responsibility Principle）指的是每一个类仅负责一项职责，当然如果更普适一些的表述，是每一个代码模块（OOP 中的类，某个函数，某个库）只负责一项职责。</p><p>这是因为当代码模块以“功能”为单位划分的时候，就符合了“高内聚，低耦合”的思想，每个模块其实以一个抽象职责的实现。代码开发者通过付出“冥思苦想提炼抽象”的代价，获得了“模块化”的优势。</p><p>当我们说“六大原则”的时候，其实是将单一职责原则剔除的，是因为这个原则在语义表述上，一点也不“单一职责”，它的思想</p><h3 id="2-2-开闭原则"><a href="#2-2-开闭原则" class="headerlink" title="2.2 开闭原则"></a>2.2 开闭原则</h3><p>开闭原则（Open Close Principle）指的是代码需要保证对于拓展开发，而对于修改关闭。说白了，就是只能增加功能，不能删除和修改功能。</p><p>代码开发者通过付出“维护一个可能更大且更冗余的代码量”的代价，获得了“向后兼容性”的优势。如何尽量规避这种代价呢？那就需要在设计之初，就尽可能避免设计出一些稳定性不强、可发展性不强的接口，避免日后为了维持这个接口而付出过大的代价。</p><h3 id="2-3-里氏代换原则"><a href="#2-3-里氏代换原则" class="headerlink" title="2.3 里氏代换原则"></a>2.3 里氏代换原则</h3><p>里氏代换原则（Liskov Substitution Principle, LSP）指的是任何基类可以出现的地方，子类一定可以出现。也就是说，基类和子类是“接口-实现”的关系。</p><p>里氏规则明确了接口和实现的分离关系，这样无论实现怎么变化（多种接口），接口都可以保持稳定。</p><p>里氏规则要求写出来的代码遵循这样的一种原则“如果鸟（基类）是会飞的，鸵鸟是一种鸟，那么鸵鸟就应该会飞”。而不幸的是，鸵鸟真的不会飞。所以基类（其实就是接口）的实际人员，就要避免给接口设计出像“飞”这样的非普适功能，或者避免将“鸵鸟”加入“鸟类”。</p><h3 id="2-4-依赖倒置原则"><a href="#2-4-依赖倒置原则" class="headerlink" title="2.4 依赖倒置原则"></a>2.4 依赖倒置原则</h3><p>所谓的依赖倒置，就是一个代码模块，是它的接口决定了它如何实现，而不是它的实现决定了它的接口。实现依赖接口，而非反过来。</p><p>这是因为实现细节具有多变性，而接口需要相对稳定。</p><h3 id="2-5-接口隔离原则"><a href="#2-5-接口隔离原则" class="headerlink" title="2.5 接口隔离原则"></a>2.5 接口隔离原则</h3><p>接口隔离原则（Interface Segregation Principle）指的是接口之间的功能都要彼此隔离而不是耦合在一起（其实也是单一职责原则的一种体现）。这是因为耦合对于维护是不利的，耦合会让依赖增多。</p><h3 id="2-6-最小知道原则"><a href="#2-6-最小知道原则" class="headerlink" title="2.6 最小知道原则"></a>2.6 最小知道原则</h3><p>最小知道原则（Demeter Principle）指的是一个接口应该与尽量少的其他接口发生相互作用。也是减少依赖的方式。</p><h3 id="2-7-合成复用原则"><a href="#2-7-合成复用原则" class="headerlink" title="2.7 合成复用原则"></a>2.7 合成复用原则</h3><p>合成复用原则（Composite Reuse Principle）指的是要尽量使用组合的方式来拓展功能，而不是采用继承的方式拓展功能。因为继承方式在某种意义上，是将基类形成了一种接口，而有些基类并没有经过良好的设计（它实现的时候是别人的子类），这种继承会引入性质不优良的接口。</p><p>而组合只是拓展了功能，并没有引入新的抽象。</p><hr><h2 id="三、设计模式"><a href="#三、设计模式" class="headerlink" title="三、设计模式"></a>三、设计模式</h2><p>正如前所述，设计模式是针对特定场景来优化代码复杂度的方案，也就是哪里复杂了，哪里才需要设计模式。设计模式可以分成“创建型，结构型，行为型”三类，分别对应一个模块在创建时、静态结构上、动态运行逻辑上产生复杂度时的应对方案。</p><h3 id="3-1-创建型模式"><a href="#3-1-创建型模式" class="headerlink" title="3.1 创建型模式"></a>3.1 创建型模式</h3><h4 id="3-1-1-工厂方法"><a href="#3-1-1-工厂方法" class="headerlink" title="3.1.1 工厂方法"></a>3.1.1 工厂方法</h4><p>工厂方法解决的问题是，对于一个普通的对象创建，我们一般直接调用构造器方法，而这种方式有时的表达能力是不够强的。</p><p>比如说对于很多常量，我们并不需要每次都创建一个新的对象，我们可以共享对象，反正没人可以修改这些共享对象。但是只要一调用构造器，那么就会产生一个新的对象。再比如，我们希望采用批处理的形式构造对象，那么使用构造器就没有办法做到。</p><p>为了实现这些更多的语义，一个比较自然的想法就是在创建对象的上下文中加上一些代码，但是因为对象的创建可能弥散在各个地方，这些代码也会被复制很多份，就很复杂。所以更好的方法就是定义一个“工厂方法”，将这些语义集成进去，就更好维护了。</p><p>我觉得工厂方法是唯一值得介绍的创建型方法，因为只有它在将复杂的构造代码提炼出一个新的抽象。其他模式都可以看作是在工厂方法上做出的改进。</p><h4 id="3-1-2-抽象工厂"><a href="#3-1-2-抽象工厂" class="headerlink" title="3.1.2 抽象工厂"></a>3.1.2 抽象工厂</h4><p>也就是存在多个工厂，这些工厂有一个共同的父类“抽象工厂”，这样我们就可以用不同的工厂（相当于具体的实现）来实现不同的构造策略。</p><h4 id="3-1-3-生成器"><a href="#3-1-3-生成器" class="headerlink" title="3.1.3 生成器"></a>3.1.3 生成器</h4><p>它指的是将构造过程拆分成多个步骤，每个步骤使用一个工厂方法。这种方法的好处除了可以让代码模块更加小以外，也更加灵活了。我们可以通过组合不同的工厂，来满足比较复杂的构造需求。</p><p>比如说对于“两轮车，三轮车，四轮车”的生产，我们可以简单的构造“两轮车工厂，三轮车工厂，四轮车工厂”。当然我们也可以只维护“车壳工厂”和“车轮工厂”两个工厂来满足这种复杂的构造需求。</p><p>生成器本质是对于构造功能的解耦和自由组合。</p><h4 id="3-1-4-原型"><a href="#3-1-4-原型" class="headerlink" title="3.1.4 原型"></a>3.1.4 原型</h4><p>当我们存在复制一个对象的需求的时候，其实是有两种思路的，方案 1 ：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>A a<span class="token punctuation">,</span> b<span class="token punctuation">;</span><span class="token comment">// copy a to b</span>b<span class="token punctuation">.</span>x <span class="token operator">=</span> a<span class="token punctuation">.</span>x<span class="token punctuation">;</span>b<span class="token punctuation">.</span>y <span class="token operator">=</span> a<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方案是有复制需求的一方在完成复制过程。</p><p>方案 2 :</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        A b<span class="token punctuation">;</span>        b<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>x<span class="token punctuation">;</span>        b<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>A a<span class="token punctuation">;</span>A b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方案是有复制需求的一方只是调用 <code>clone</code> 方法，具体的方式是交给原型来做的。</p><p>当这种复制操作比较多的时候，显然第二种方式就比较好了；此外，当被复制的一方有私有数据时，也是第二种方式比较好。</p><h4 id="3-1-5-单例"><a href="#3-1-5-单例" class="headerlink" title="3.1.5 单例"></a>3.1.5 单例</h4><p>就是全局只有一个对象的情况，其实是和 Java 具体的语法联系比较紧密了，没有什么设计上的借鉴价值。</p><h3 id="3-2-结构型模式"><a href="#3-2-结构型模式" class="headerlink" title="3.2 结构型模式"></a>3.2 结构型模式</h3><h4 id="3-2-1-适配器"><a href="#3-2-1-适配器" class="headerlink" title="3.2.1 适配器"></a>3.2.1 适配器</h4><p>适配器模式是 Adapter，也称 Wrapper，是指如果一个接口需要 B 接口，但是待传入的对象却是 A 接口，怎么办？</p><p>那么就在 A 外面套一层满足 B 接口的适配器就可以了。</p><h4 id="3-2-2-桥接"><a href="#3-2-2-桥接" class="headerlink" title="3.2.2 桥接"></a>3.2.2 桥接</h4><p>其实这个模式很简单，它就是我们理解的“组合”，也就是每个部分只负责一些小的互相独立的功能，利用多个独立功能来组合完成复杂功能。</p><p>但是我很喜欢 Bridge 的概念，桥似乎在计算机术语中，描述的就是一种将多个功能模块组合在一起的概念，比如说芯片中的南桥和北桥芯片，网络中的桥接模式。</p><p><img src="/posts/94e7864c/bridge.png" alt="桥接设计模式"></p><p>它更像是一种“中间人”或者“平台”的概念，与汉语中的“连接和沟通两地”的概念有些出入。</p><h4 id="3-2-3-组合"><a href="#3-2-3-组合" class="headerlink" title="3.2.3 组合"></a>3.2.3 组合</h4><p>这里说的组合并不是和“继承”有对立关系的那个“组合”，而是一种树形结构，并且采用了递归处理：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toXml</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> start <span class="token operator">=</span> <span class="token string">"&lt;"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"&gt;\n"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> end <span class="token operator">=</span> <span class="token string">"&lt;/"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"&gt;\n"</span><span class="token punctuation">;</span>        <span class="token class-name">StringJoiner</span> sj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>node <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            sj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">toXml</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说就是树形结构的那些优点呗，局部的，递归的。</p><h4 id="3-2-4-装饰器"><a href="#3-2-4-装饰器" class="headerlink" title="3.2.4 装饰器"></a>3.2.4 装饰器</h4><p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</p><p>从实践角度来说，一些功能可能并不适合集成到类内部。比如说对某个类的“机械打印方法”，就是打印这个类的所有数据域（用于 debug）。这种方法显然不适合在类内部实现，不然每个类都要有这样的一个愚蠢的方法了。</p><p>所以我们可以将这个打印功能单独抽离出来，然后加到（装饰）所需要的类上，至于加的方法是基类、元编程还是什么其他手段，这就因实现而定了。</p><h4 id="3-2-5-外观"><a href="#3-2-5-外观" class="headerlink" title="3.2.5 外观"></a>3.2.5 外观</h4><p>外观模式，即 Facade ，它指的是：如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。</p><h4 id="3-2-6-享员"><a href="#3-2-6-享员" class="headerlink" title="3.2.6 享员"></a>3.2.6 享员</h4><p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p><h4 id="3-2-7-代理"><a href="#3-2-7-代理" class="headerlink" title="3.2.7 代理"></a>3.2.7 代理</h4><p>代理模式，即 Proxy 。它和 Adapter 模式很类似，它们都是在原有类上在封装一层。</p><p>我个人觉得区别是，Adapter 是为了让功能可以正常使用，而 Proxy 视为了拓展功能的使用。比如说工厂方法就可以看作是构造方法的一种代理。</p><hr><h3 id="3-3-行为型模式"><a href="#3-3-行为型模式" class="headerlink" title="3.3 行为型模式"></a>3.3 行为型模式</h3><h4 id="3-3-1-责任链"><a href="#3-3-1-责任链" class="headerlink" title="3.3.1 责任链"></a>3.3.1 责任链</h4><p>行为型模式都是为了解决复杂的业务流而提出的。责任链的概念有些类似于流水线，每个人只负责处理一小部分业务逻辑。我个人感觉其实它更像是一堆筛网的集合，液体从中流过，滤出去了不同的东西。</p><p>这种模式下，增添一个筛网或者调整筛网的顺序，都是非常容易的，我甚至品出了流处理的精神。</p><h4 id="3-3-2-命令模式"><a href="#3-3-2-命令模式" class="headerlink" title="3.3.2 命令模式"></a>3.3.2 命令模式</h4><p>这说的是，对于每个操作，我们都让他们继承自一个叫做 <code>Command</code> 的基类，这样我们就可以对于这些操作进行统一的管理，比如我们可以 <code>undo, redo</code> 这些操作，至于我们为什么要对于这些操作进行统一的管理，可能这就是具体的情景要求了（比如一个编辑器中这种操作很常见）。</p><p>我个人觉得这种思想其实有些类似于“事务”或者“函数式”的思想了，将一段可执行代码当成一个类来操作。</p><h4 id="3-3-3-解释器"><a href="#3-3-3-解释器" class="headerlink" title="3.3.3 解释器"></a>3.3.3 解释器</h4><p>其实就是对于一些特定的问题，通用的编程语言会存在冗余繁复等问题，所以可以开发 DSL 来描述业务。解释器说的就是 DSL 的方法。</p><p>那么 DSL 的解释器的开发和维护难度呢？我觉得肯定是比不开发要难的，那我们为什么还需要 DSL 呢？我觉得是因为业务逻辑本身十分复杂且有规律，所以我们将原本的“业务逻辑复杂度”拆分成了“DSL 代码复杂度 + DSL 解释器复杂度”两个部分，或许这种拆分要比之前的复杂度要低。</p><h4 id="3-3-4-迭代器"><a href="#3-3-4-迭代器" class="headerlink" title="3.3.4 迭代器"></a>3.3.4 迭代器</h4><p>迭代器在 C++ Primer 中已经讨论滥了，它忽略了不同数据结构之间的差异，让我们可以以统一的方式遍历不同数据结构中的元素。也就是说，这是一种对于“迭代”这个操作的统一抽象。</p><h4 id="3-3-5-中介"><a href="#3-3-5-中介" class="headerlink" title="3.3.5 中介"></a>3.3.5 中介</h4><p>中介模式（Mediator）是通过引入一个中介对象，把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。</p><p>说穿了，中介就是一个全局看板。</p><h4 id="3-3-6-备忘录"><a href="#3-3-6-备忘录" class="headerlink" title="3.3.6 备忘录"></a>3.3.6 备忘录</h4><p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p><p>我是觉得它和“原型”差不多。</p><h4 id="3-3-7-观察者"><a href="#3-3-7-观察者" class="headerlink" title="3.3.7 观察者"></a>3.3.7 观察者</h4><p>我觉得就是发布-订阅模式，是一种一对多的通知机制，使得双方无需关心对方，只关心通知本身。</p><h4 id="3-3-8-状态"><a href="#3-3-8-状态" class="headerlink" title="3.3.8 状态"></a>3.3.8 状态</h4><p>状态模式类似于状态机的理念，也就是根据状态产生不同的行为。</p><p>在具体的代码实现中，有一个 <code>State</code> 基类，它定义了一个 <code>process()</code> 纯虚方法，不同的状态继承这个基类并覆盖了 <code>process</code> 方法。</p><h4 id="3-3-9-策略"><a href="#3-3-9-策略" class="headerlink" title="3.3.9 策略"></a>3.3.9 策略</h4><p>策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p><h4 id="3-3-10-模板方法"><a href="#3-3-10-模板方法" class="headerlink" title="3.3.10 模板方法"></a>3.3.10 模板方法</h4><p>模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p><p>因此，模板方法的核心在于定义一个“骨架”。</p><h4 id="3-3-11-访问者"><a href="#3-3-11-访问者" class="headerlink" title="3.3.11 访问者"></a>3.3.11 访问者</h4><p>访问者模式（Visitor）是一种操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p><p>有一说一非常复杂，我看懂了，但是我觉得没有什么特殊的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、总论&quot;&gt;&lt;a href=&quot;#一、总论&quot; class=&quot;headerlink&quot; title=&quot;一、总论&quot;&gt;&lt;/a&gt;一、总论&lt;/h2&gt;&lt;p&gt;设计模式是一个工程问题，它不能为某个问题提供具体的答案，它只能让答案写得好看一些。&lt;/p&gt;
&lt;p&gt;更进一步地说，设计模式是用于解决代码复杂度高（不是算法复杂度）的问题，这会引发难以阅读，难以维护等伴生问题。当代码量小，复杂度低，没有什么维护需求的时候（比如说科研代码），其实是没有必要采用规范的设计模式的。&lt;/p&gt;
&lt;p&gt;我个人学习设计模式，并不是为了写代码（因为我写的代码就是科研代码），而是为了更好的阅读代码，因为大型工程代码都会或多或少遵循设计模式的思路。&lt;/p&gt;
&lt;p&gt;很多设计模式解决的复杂度问题，是客观存在的，认识这些问题有助于设计出更加简洁健壮的架构；但是有些问题可能只是类似 Java 等语言表述能力不够所导致的，不用太较真。&lt;/p&gt;</summary>
    
    
    
    <category term="面向对象" scheme="https://thysrael.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="面向对象" scheme="https://thysrael.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="S8 假期" scheme="https://thysrael.github.io/tags/S8-%E5%81%87%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成-乱序</title>
    <link href="https://thysrael.github.io/posts/af364ce6/"/>
    <id>https://thysrael.github.io/posts/af364ce6/</id>
    <published>2024-08-10T11:50:16.000Z</published>
    <updated>2024-10-17T06:35:03.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><p>乱序指的是指令并不按照顺序执行，所以这个概念比较接近软件编程中的“异步”概念（强调对于顺序时序的破坏）。而我之前似乎一直把它和“并行”挂钩（强调对于共享资源的争用）。这种认识倒也不算是错误，目前学了一圈下来，感觉其实和两个概念都有关系。</p><p>在顺序模型下，指令是一条条阻塞执行的，必须前一条指令执行完，才能执行后一条指令。那么如果前一条指令非常花时间，那么后一条指令就只能阻塞等待。这个问题是用流水线解决不了的。流水线中的指令也需要顺序执行。而乱序执行就打破了这种顺序执行的阻塞性，使得前序和后序指令可以并行执行。</p><hr><h2 id="二、冒险（hazard）"><a href="#二、冒险（hazard）" class="headerlink" title="二、冒险（hazard）"></a>二、冒险（hazard）</h2><p>我们希望 CPU 按照理想情况运行，那么什么是理想情况？对于单个处理器核心，当：</p><script type="math/tex; mode=display">指令执行速度 = 时钟频率 \times 流水线深度 \times 数据通路条目</script><p>时就是理想情况了。而在现实生活中，常常因为多种现实因素使得指令的执行速度减慢，这些现实因素被称为“冲突（hazard）”。具体有 3  种：</p><ul><li>结构冲突（structure）：指的是对于功能单元的竞争情况，比如两个指令都需要 ALU，而只有一个 ALU，那么这两条指令就只能串行。</li><li>分支冲突（branch）：指的是因为分支而导致的指令流中断，比如突然发现正在执行的指令属于不会被执行的分支，那么这些指令都需要撤销。</li><li>数据冲突（data）：指令需要的数据还没有被前一条指令计算出来，那么就会导致阻塞。</li></ul><p>CPU 种有很多功能单元（也可以看作计算资源），我们希望让他们都运转起来，不要闲置或者做无用功。但是每条指令并不会“同时”使用这些资源，比如对于一条指令的执行，只要取出指令后，就不需要再从 I-Cache 中读值了，当这条指令让 ALU 进行运算的时候，Fetch，Decode，Write Back 这些单元是闲置的。所以我们发明了流水线技术，将功能单元划分到不同的流水级，每个流水级都运行一条指令，这样就可以并行利用不同的资源。但是这样还不够，因为可能一个阶段里还有很多个功能单元，比如说 Execute Stage 里就有整数计算单元，浮点数计算单元，访存单元等，这些单元想要满载运转，就不能再采用流水线技术了，因为这些资源并不是每条指令都会用到，如果我们将 Execute Stage 拆分成 Calculate Stage 和 Memory Stage ，那么 Memory Stage 的资源就会在执行计算指令时被闲置，而 Calculate Stage 的资源则会在执行访存指令时被闲置，所以我们可以采用乱序的方式，让一个流水级中包含多条指令，比如 Execute Stage 就可以同时包含一条计算指令和一条访存指令，这样资源就可以得到更充分的利用。</p><p>总得来说，我们可以利用流水线技术和乱序技术对 CPU 内的资源进行不同维度的并行操作：</p><p><img src="/posts/af364ce6/cpu.png" alt="cpu"></p><p>从这个角度看，流水线深度并不是越深越好，因为被时序分割的资源，并不会在每条指令上得到充分利用，反而是乱序的方式，更能充分利用资源。</p><p>总得来说，我们对于明显有依赖关系的资源，会采用流水线的方式来并行，比如说取指单元和译码单元的流水线处理；而对于没有依赖关系的资源，我们会采用乱序的方式并行，比如访存单元和计算单元的乱序。更进一步辩证地看，在同一级流水线中，一定存在没有依赖关系的资源，那么就是可以乱序的；在</p><hr><h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><p>我觉得我自己之所以谈到更加高级的 CPU 特性，比如说乱序、分支预测谈虎色变，是因为我在心里认为在硬件上是没有办法实现过于复杂的算法的。但是这种观点是很不精确的，硬件和算法的复杂程度没有必然联系，不过确实在硬件上实现的算法会有一些硬件特征。</p><p>首先是在 CPU 中是没有内存的，所以也就没有地址。这里很容易产生一个误导，就是同样没有指针。这是不对的，算法需要的并不是一个具体的指针，它只需要一个“指向某个数据的变量”即可，所以没有指针，也可以用整型索引代替。这有点像算法竞赛在实现链表，树之类的数据结构的时候，都不会使用指针，而是提前开一个大数组，然后用索引来指向其中的元素的思想。</p><p>然后是在 CPU 中没有像高级语言的“无限”概念的，任何资源都是有数量限制的。不仅是资源的数量有限制，资源的规模也有限制，比如说一个整数寄存器，就是 32 位，如果希望表达一个更大的数，那么就没有办法了。不过这种限制其实很好解决，只需要阻塞 CPU 直到相关资源富裕就可以了，常见的问题有空闲物理寄存器数目不够，指令编号溢出，队列溢出等。</p><p>还有一种解决资源有限的方法，是将资源的状态都保存到内存中，不过这种方法在微体系结构中用得不多（时间开销太大），但是在编译器开发中很常见。</p><p>最后是 CPU 上的算法的局部性很强，而且是只有一遍的，我们只能看到 CPU 上运行的这几条指令，或者还有一些 buffer 指令，而且只能看见一次。这就导致很多全局算法我们是没有办法直观实现的，但是我们可以采用一种像“流”或者是“滑动窗口”的思想去从局部推断全局。</p><p>总得来说，CPU 的性质使得它在描述算法或者数据结构的时候，会呈现一种朴素的，有限的、狭隘的特征，但是基本上没有算法是用 CPU 无法表示的（复杂的森林和图都是可以的），所以当我们去看 CPU 上的特征时，应当从它笨拙的表达中，看出其背后的精妙算法。</p><hr><h2 id="四、假冒险"><a href="#四、假冒险" class="headerlink" title="四、假冒险"></a>四、假冒险</h2><p>这里讨论的真假冒险都是数据冒险的一种，其实就是对于数据依赖关系的讨论。出现数据冒险问题，是优于前序指令（一个装逼的说法，就是在汇编中位置靠前的指令）晚于后序指令提交造成。</p><p>所谓的真冒险，就是“写后读”（Read After Write，RAW），吐槽一句，可以发现在中文这个词是先写后读，而在英文中变成了下先 R 后 W，刚好是反过来的，后面我只用英文。至于为什么它是真冒险，是因为只有前序指令写入了这个数据，后序指令才能读入新的值。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">write r0read r0 # commit first, error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与之相对的，有 WAR 和 WAW 两种假冒险。对于 WAR 而言，先序指令读，后序指令写，我们担心的是，后序指令先提交的情况，但是如果后序指令没有提交到原本的寄存器中呢，那么就不存在问题了，换句话说，如果有无限个寄存器（类似于无限个变量），那么谁还为了省一些寄存器，而去覆盖一个可能还会被读的寄存器。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">read r0write r0 # commit first, error### good ###read r0write r1 # commit first, correct<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至于如何让寄存器变成无限个，那其实就又很多种办法了，大不了阻塞 CPU 嘛。当然在实际应用中，我们会通过重命名的手段，在内存中维护一个从逻辑寄存器到实际寄存器的映射关系，来使得不会发生依赖现象，这就是寄存器重命名。</p><p>而寄存器重命名算法，在原理上和编译器的寄存器分配算法的需求是一样的，唯一的区别在于编译器的逻辑寄存器不够了，那么就会往栈上存，而 CPU 的物理寄存器不够了，就会阻塞 CPU。当然了，像图着色或者线性扫描这种方法是没法用到 CPU 上，CPU 一般就是维护一个空闲寄存器队列就够了。</p><hr><h2 id="五、计分板"><a href="#五、计分板" class="headerlink" title="五、计分板"></a>五、计分板</h2><blockquote><p>从任何意义上说，寄存器就是内存的一个过客。</p></blockquote><p>如果我们拨开 ISA 的复杂性的迷雾，就会发现 CPU 的核心在于“读入内存，计算，写入内存”的图灵机模式，其中的计算步骤，其实就是构建一个计算的 DAG 图（有向无环图），其结构如下：</p><p><img src="/posts/af364ce6/dag.drawio.png" alt="dag.drawio"></p><p>寄存器的作用就是存储这些 DAG 图的中间节点。这里面的 <code>(1), (2), (3)</code> 可能就分别对应某个寄存器。</p><p>所谓的计分板，就是描述这幅图的数据结构，他的每个条目就是图上的一个点</p><div class="table-container"><table><thead><tr><th>ID</th><th>ready</th><th>child</th></tr></thead><tbody><tr><td>(1)</td><td>false</td><td>a, b</td></tr><tr><td>(2)</td><td>false</td><td>(1), a</td></tr><tr><td>(3)</td><td>true</td><td>b, d</td></tr></tbody></table></div><p>那么为什么要保留这样的一个结构，因为这个结构非常方便查看是否允许并行并处理相关的数据依赖。</p><p>比如在计分板上，我们就知道 <code>(2)</code> 这条指令还没有办法进行计算，因为 <code>(1)</code> 还没有算完，但是 <code>(3)</code> 已经可以算了，也就是 <code>(1), (3)</code> 可以并行计算，而 <code>(2)</code> 不可以。我们还可以看出 <code>(1), (3)</code> 都依赖 <code>b</code> 这个节点。而且这里的 ID 可以理解成一种逻辑寄存器，我们可以将其分配给物理寄存器。</p><p>总之计分板就是这样的一个全局看板结构，基于 DAG 图的方式来协调乱序并行。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、总论&quot;&gt;&lt;a href=&quot;#一、总论&quot; class=&quot;headerlink&quot; title=&quot;一、总论&quot;&gt;&lt;/a&gt;一、总论&lt;/h2&gt;&lt;p&gt;乱序指的是指令并不按照顺序执行，所以这个概念比较接近软件编程中的“异步”概念（强调对于顺序时序的破坏）。而我之前似乎一直把它和“并行”挂钩（强调对于共享资源的争用）。这种认识倒也不算是错误，目前学了一圈下来，感觉其实和两个概念都有关系。&lt;/p&gt;
&lt;p&gt;在顺序模型下，指令是一条条阻塞执行的，必须前一条指令执行完，才能执行后一条指令。那么如果前一条指令非常花时间，那么后一条指令就只能阻塞等待。这个问题是用流水线解决不了的。流水线中的指令也需要顺序执行。而乱序执行就打破了这种顺序执行的阻塞性，使得前序和后序指令可以并行执行。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二、冒险（hazard）&quot;&gt;&lt;a href=&quot;#二、冒险（hazard）&quot; class=&quot;headerlink&quot; title=&quot;二、冒险（hazard）&quot;&gt;&lt;/a&gt;二、冒险（hazard）&lt;/h2&gt;</summary>
    
    
    
    <category term="计算机组成" scheme="https://thysrael.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="S8假期" scheme="https://thysrael.github.io/tags/S8%E5%81%87%E6%9C%9F/"/>
    
    <category term="计算机组成" scheme="https://thysrael.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>海边拾贝-VeriSMo</title>
    <link href="https://thysrael.github.io/posts/71c079c7/"/>
    <id>https://thysrael.github.io/posts/71c079c7/</id>
    <published>2024-07-29T01:25:40.000Z</published>
    <updated>2024-10-17T06:35:03.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/posts/71c079c7/1600x900_1591431860952_2048x1152_logo.jpg" alt="A RaiPlay learning il Verismo e i suoi autori - RAI Ufficio Stampa"></p><p>VeriSMo 的可信基只包括硬件和它自己（VM），剔除了对于 Hypervisor 的信任。传统的 VM 的安全服务是由 Hypervisor 负责的，如果认为 Hypervisor 是不可信的，那么就不能由它来提供安全服务。AMD 提供了新的安全架构 SEV-SNP，它为在 VM 中独立实现安全服务提供了支持，VeriSMO 就利用了这个硬件特性。</p><p>除了利用新的硬件安全特性外，VeriSMo 在开发时完成了形式化验证来确保安全性。VeriSMo 的开发语言是 Rust，已经确保了部分的内存安全性（也就是 Rust Checker 承担了部分形式化验证的任务），距离完全的形式化验证还有两个挑战：</p><ol><li>因为 Hypervisor 不可信任，所以 Hypervisor 可以打断 VM 的执行并修改硬件状态，这种并行无法简单验证。</li><li>开发 VeriSMo 需要使用 Unsafe Rust，Rust Checker 无法验证这种情况。</li></ol><p>为了解决挑战 1，VeriSMo 将验证拆分成了 2 层，上层为机器模型层（Machine Model），用 model verify 专门约束 Hypervisor 的行为，下层为实现层（Implement），用于解决排除了 Hypervisor 干扰后的 VeriSMo 本身的验证问题。</p><p>为了解决挑战 2，VeriSMo 引入并拓展了 Verus 来对 Unsafe 的情况进行验证，Verus 是 Rust 的一个库，可以看作它强化了原本的 Checker 功能；</p><h2 id="一、技术背景"><a href="#一、技术背景" class="headerlink" title="一、技术背景"></a>一、技术背景</h2><p>这个项目使用了大量的第三方技术和理论（多到和我用技术背景水字数的毕设差不多比例了）。</p><h3 id="1-1-理论"><a href="#1-1-理论" class="headerlink" title="1.1 理论"></a>1.1 理论</h3><p>reference：</p><p><a href="https://blog.lucode.net/theory/PV-HoareLogic.html">程序验证技术——霍尔逻辑 - 撸代码 - LuCode.net</a></p><h4 id="1-1-1-验证逻辑"><a href="#1-1-1-验证逻辑" class="headerlink" title="1.1.1 验证逻辑"></a>1.1.1 验证逻辑</h4><p>在验证逻辑方面并没有“显式”使用，只需要明确它们都涉及了 Rust Borrower Checker 和 Verus 的基础理论。其中尤其是线性逻辑，是可以支持并行程序内部的验证的，所以 VeriSMo 作为一个并行程序，形式化验证并没有理论上的难度，只是在实现上存在难度。</p><h4 id="1-1-2-验证等级"><a href="#1-1-2-验证等级" class="headerlink" title="1.1.2 验证等级"></a>1.1.2 验证等级</h4><p>形式化验证有两个等级：模型（Model）级别和实现（Implement）级别。其中实现级别的验证就是直观的对于具体的代码的形式化验证。而模型级别的验证是验证抽象模型，而不是具体的代码实现。这些模型通常通过状态机、流程图或其他形式化描述来表示。</p><p>在本项目中，验证分为两层，其中对于机器层的验证，就是模型级的，对于 VeriSMo 本身的验证，是实现级的。</p><h3 id="1-2-硬件"><a href="#1-2-硬件" class="headerlink" title="1.2 硬件"></a>1.2 硬件</h3><p>reference：</p><p><a href="https://dl.acm.org/doi/fullHtml/10.1145/3623392">Hardware VM Isolation in the Cloud</a></p><p><a href="https://blog.csdn.net/qq_43543209/article/details/135652011">【TEE】【AMD SEV内存加密】 白皮书-CSDN博客</a></p><p>硬件特性有很多，其核心在于将原本由 Hypervisor 负责的安全功能全部提供给 VM 。</p><h4 id="1-2-1-加密内存"><a href="#1-2-1-加密内存" class="headerlink" title="1.2.1 加密内存"></a>1.2.1 加密内存</h4><p>SME（Secure Memory Encrypted）：写入内存时利用硬件生成的 VM-specific key 对数据加密，读取内存是对数据解密。VM 可以通过 PTE 中的 <code>C-bit</code> 对物理页进行选择性加密。</p><p><img src="/posts/71c079c7/pic1.PNG" alt="pic1"></p><p>SEV-SNP 引入了反向映射表（RMP，Reverse Map Table）。之所以称之为反向映射表，是因为在传统的 VM 地址翻译中，映射方向是：</p><blockquote><p>gVA =&gt; gPA（guest 物理地址） =&gt; sPA（系统物理地址）</p></blockquote><p>而 RMP 中记录的是：</p><blockquote><p>sPA =&gt; {gPA, valid_bit, ASID}</p></blockquote><p>与传统方向相反。</p><p>RMP 的设计主要是为了使得物理内存真的分配给了特定的 VM，恶意的 Hypervisor 无法欺骗 VM 。当 Hypervisor 给 VM 分配内存时，需要使用特定的 <code>rmpupdate</code> 指令，VM 需要使用 <code>rmpvalid</code> 指令确认此次分配符合自己的要求。一旦分配完成后，Hypervisor 就无法再写入该内存页面了。后续 VM 可以使用 <code>rmpupdate</code> 来调整权限或者映射关系。</p><p>采用反向映射的方式，在地址翻译的时候增添一次映射来核对 GPA （GPA 是否真的对应特定的 SPA）和 ASID （VM 是否真的是特定的 VM）来确保“恶意 Hypervisor 无法尝试将页面映射到 Guest 地址空间中的错误位置”。</p><p><img src="/posts/71c079c7/pic2.png" alt="pic2"></p><h4 id="1-2-2-上下文加密"><a href="#1-2-2-上下文加密" class="headerlink" title="1.2.2 上下文加密"></a>1.2.2 上下文加密</h4><p>ES（Encrypted state）：在 VM 内陷到 Hypervisor 的时候，CPU 的状态会被加密保存到 VM Saving Area (VMSA) 。</p><h4 id="1-2-3-安全中断"><a href="#1-2-3-安全中断" class="headerlink" title="1.2.3 安全中断"></a>1.2.3 安全中断</h4><p>当限制中断（restricted）被启用时，Hypervisor 只能注入一种叫作 #HV 的中断，当 #HV 中断到达某个 VMPL 时，该 VMPL 的 VM 代码可以参考 #HV 门铃页来检查中断类型，而不是直接跳转到任意的中断处理程序。</p><p>共享门铃页（Shared Doorbell Page）是一个内存页面，被 Hypervisor 和 VM 的不同权限级别共享，用于传递中断和事件通知的信息。当 Hypervisor 发生注入某个特定类型的中断的时候，可以先修改门铃页来记录要触发的中断类型，然后给 VM 注入 #HV 中断，VM 收到 #HV 中断后会查看门铃页里的中断类型，进而做出相应处理。而不是直接被 Hypervisor 改变程序流。</p><p>VeriSMo 启用了 restricted-mode，减少了 Hypervisor 中断注入攻击的攻击面。</p><h4 id="1-2-4-虚拟机特权等级"><a href="#1-2-4-虚拟机特权等级" class="headerlink" title="1.2.4 虚拟机特权等级"></a>1.2.4 虚拟机特权等级</h4><p>在经历了内存加密和寄存器加密后，其实特权等级模型已经发生了变换。传统的特权等级模型下，高特权级可以随意访问低特权级的资源，随意影响低特权级软件的程序流（中断）；但是在 AMD SEV 中，即使是高特权级也无法访问一些低特权级的资源。</p><p><img src="/posts/71c079c7/pic3.png" alt="pic3"></p><p>更进一步，SEV-SNP 提供了 VMPL（虚拟机特权级别）的功能。该功能允许进行额外的安全控制，以保护 guest 内部的内存免受同一 guest 中其他代码的影响。每个 guest 最多可以有四个 VMPL，其中 VMPL0 权限最高，VMPL3 权限最低。分配给 guest 的每个内存页面可能具有基于 VMPL 的不同权限。 VMPL0 始终具有对 guest 地址空间中每个页面的完全访问权限，但它可能会将某些页面配置为不可在 VMPL1 上访问，或者可能允许只读访问。</p><p>VeriSMo 就是一个运行在 VMPL0 上的软件，而 Guest OS 运行在 VMPL3（只要不是 VMPL0 就行）上，这样可以避免不受信任的 Guest OS 的攻击。VMPL0 除了可以管理</p><h3 id="1-3-软件"><a href="#1-3-软件" class="headerlink" title="1.3 软件"></a>1.3 软件</h3><p>reference：</p><p><a href="https://verus-lang.github.io/verus/guide/">Verus Tutorial and Reference</a></p><h4 id="1-3-1-Rust-Checker"><a href="#1-3-1-Rust-Checker" class="headerlink" title="1.3.1 Rust Checker"></a>1.3.1 Rust Checker</h4><p>Rust 的所有权系统和类型系统确保了一定的安全性，但是 Unsafe Rust 可能会导致 bug 或者安全性问题。</p><h4 id="1-3-2-Verus"><a href="#1-3-2-Verus" class="headerlink" title="1.3.2 Verus"></a>1.3.2 Verus</h4><p>Verus 是一个为 Rust 设计的形式化验证工具，它看上去就像一个被拓展了语法的 Rust。</p><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">verus! {fn octuple(x1: i8) -&gt; (x8: i8)    requires        -16 &lt;= x1 &lt; 16,    ensures        x8 == 8 * x1,{    let x2 = x1 + x1;    let x4 = x2 + x2;    x4 + x4}fn main() {    let n = octuple(10);    assert(n == 80);}} // verus!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以注意到相比于普通的 Rust，多加了 <code>requires, ensures, invarient</code> 等关键词，这些是形式化验证的“方法”。本项目不仅实现了一个经过验证的模块，还将验证方法都用 rust 或者说 verus 实现了。</p><hr><h2 id="二、设计"><a href="#二、设计" class="headerlink" title="二、设计"></a>二、设计</h2><h3 id="2-1-威胁模型"><a href="#2-1-威胁模型" class="headerlink" title="2.1 威胁模型"></a>2.1 威胁模型</h3><p>VeriSMo 的可信基只包括硬件和它自己（运行在 VMPL0 上的 VeriSMo），它既不信任 Hypervisor，也不信任运行在 VMPL3 的 Guest OS。</p><p><img src="/posts/71c079c7/pic4.png" alt="pic4"></p><p>VeriSMo 在这样的模型下，要完成唤醒 CPU，管理 Guest 内存，确保 Guest OS 的完整性，运行时测量等功能。</p><p><img src="/posts/71c079c7/pic5.png" alt=""></p><h3 id="2-2-验证目标"><a href="#2-2-验证目标" class="headerlink" title="2.2 验证目标"></a>2.2 验证目标</h3><p>我们希望用形式化验证的方式确定 3 个属性：</p><ul><li>功能正确性：VeriSMo 可以无 bug 地满足安全服务所需要的功能。</li><li>信息流安全：程序在任何情况下都不应通过内存操作或低安全级别变量的值泄露与高安全级别变量相关的信息。</li><li>VM 的机密性和可信性：Hypervisor 和 VMPL3 都不可以读取 VMPL0 的私有内存。Hypervisor 不可以读取 VM 的私有内存（应该是包括 VMPL0 和 VMPL3 的私有内存）。</li></ul><p>总的来说有两个目标，一个是内存安全，一个是信息流安全。文章比较大的篇幅集中于内存安全，而信息流安全的验证则和其他部分比较孤立，最后单独形成一个章节介绍。</p><h3 id="2-3-验证思路"><a href="#2-3-验证思路" class="headerlink" title="2.3 验证思路"></a>2.3 验证思路</h3><p>Hypervisor 会打断 VM 对资源形成并发操作，然而因为不信任 Hypervisor 的原因，我们无法直接验证 Hypervisor ，所以我们将验证分成了两层。第一层是 Machine Model Layer，采用建立一个硬件抽象机的方式进行模型级的验证，确保在给定 Hypervisor 约束后，它不会影响 VM 的机密性和完整性。第二层是 VeriSMo 内部实现的验证。</p><p><img src="/posts/71c079c7/1722216940888-14.png" alt="img"></p><p>我个人感觉形式化验证是可以验证并发程序的，此项目分成两层进行验证，有可能不是因为 Hypervisor 的并发很难验证，而是因为 Hypervisor 不在信任基内，导致我们没法直接验证，所以我们才采用了建模的方式进行抽象验证。</p><p>我个人感觉其实是将验证分为了两步：</p><ul><li>Machine-Model Layer：验证 AMD SEV-SNP 这套硬件机制没有问题</li><li>Implement Layer：验证 VeriSMo 对 AMD SEV-SNP 的使用没有问题</li></ul><hr><h2 id="三、内存安全验证"><a href="#三、内存安全验证" class="headerlink" title="三、内存安全验证"></a>三、内存安全验证</h2><h3 id="3-1-Machine-Model-层"><a href="#3-1-Machine-Model-层" class="headerlink" title="3.1 Machine-Model 层"></a>3.1 Machine-Model 层</h3><p>Machine Model 具有两个目标：</p><ul><li>Hypervisor 和 VMPL3 都不可以读取 VMPL0 的私有内存。</li><li>Hypervisor 不可以读取 VM 的私有内存（应该是包括 VMPL0 和 VMPL3 的私有内存）。</li></ul><p>更进一步地说，我们希望验证这个图片所展示的事实，即 HV 和 VM 具有一定的独立性：</p><p><img src="/posts/71c079c7/1722216970526-17.png" alt="img"></p><p>VERISMO 并没有一个 guest OS 那么庞大，所以 VERISMO 只对关键的内存和 cache 操作进行建模。</p><p>其更加具体地说，它的主线逻辑是这样的，它定义了 4 个对象：</p><ul><li>系统状态（Ψ）：整个系统</li><li>实体（e）：可能是 Hypervisor、VeriSMo，Guest OS </li><li>操作（op）：关键的内存和 cache 操作，比如更新页表之类的。</li><li>攻击模型（attack model）：Ψ 按照一定顺序经过多个 e 的多个 op 的一个序列</li></ul><p>如果 Ψ 初始化是正确的，所有的 op 都满足各自的前置条件和后置条件，验证 Ψ 经过 op 后依然安全（保证一定的不变式），那么按照类似数学归纳法的思想，经过多次 op 后 Ψ 依然安全。</p><p>那么检验的核心就在于 op 的约束条件（前置和后置）能否满足上述要求。这就需要结合硬件特性来推导出一些比较强的引理来。</p><p>关于 VM-Private 的内存，我们有：</p><ul><li>Ψ 下 CVM 私有内存 M 包含数据 D，经由 HV 操作后， Ψ’ 下 CVM 读取 M 得到数据 D 或读取失败。</li></ul><p>这是因为 RMP 规定如果该 M 不是 valid 的，那么 HV 是可以读取的，而如果是 valid 的，那么就不可以读取。</p><ul><li>Ψ 下 CVM 私有内存 M 包含机密 S，经由 HV 操作后， Ψ’ 下 HV 读取 M 得到 S 的密文。</li></ul><p>如果经过加密，那么读取到的一定是密文。</p><p>关于 VMPL0-Private 的内存，我们有：</p><ul><li>Ψ 下 VMPL0 私有内存 M 包含数据 D，经由 hypervisor 或 VMPL3 操作后， Ψ’ 下 VMPL0 读取 M 得到数据 D 或读取失败，VMPL3 不能读取 M。</li></ul><p>由引理 1，2 可以 HV 不可读取，又因为 RMP 中记录了每个 VMPL 的访问权限，VMPL3 没有访问权限。</p><p>关于地址翻译，我们有：</p><ul><li>Ψ 下 VMPL0 访问 gVA 翻译到 sPA，经由 HV 或 VMPL3 操作后，Ψ’ 下 VMPL0 访问 gVA 翻译到 sPA 或翻译失败。</li></ul><p>只有使用 VMPL0 的特殊指令才能更改页表，任何其他更改页表的行为都会导致报错。</p><ul><li>任何 Ψ 下，CVM 的 gVA 到 sPA 的映射是双射。</li></ul><p>因为 gPA 到 sPA 的映射是双射，只需要证明 gVA 到 gPA 是双射。具体的证明方法类似于“一开始是双射，而且每次操作都必须保证是双射的，所以最后是双射”的数学归纳法。</p><p>在有了这五条引理后，就可以交给形式化证明机来完成证明了。</p><h3 id="3-2-Implement-层"><a href="#3-2-Implement-层" class="headerlink" title="3.2 Implement 层"></a>3.2 Implement 层</h3><p>在实现层，验证上主要采用如下技术来实现形式化验证：</p><p><img src="/posts/71c079c7/1722216970526-18.png" alt="img"></p><p>其中 Rust 负责基础的所有权和读写检查，SNP Pointer 是一个用于验证的胖指针，里面对 SEV-SNP 机制进行了建模，胖指针的样子是这样的</p><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">pub ghost struct SnpMemAttr{ rmp: RmpEntry, pte: PTAttr, is_pt: bool}pub ghost struct SnpPointsToData&lt;T&gt; {    addr: int, value: Option&lt;T&gt;,    swattr: SnpMemAttr, hwattr: SnpMemAttr,}pub tracked struct SnpPointsTo&lt;V&gt;{ _p: marker::PhantomData&lt;V&gt;, _ncopy: NoCopy }impl&lt;T&gt; SnpPointsTo&lt;T&gt;{ pub spec fn view(&amp;self) -&gt; SnpPointsToData&lt;T&gt;; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检验者可以根据胖指针内 <code>RmpEntry, addr</code> 等元素进行验证。如下所示：</p><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn access_private(Tracked(mperm): Tracked&lt;&amp;SnpPointsTo&lt; u64&gt;&gt;)    requires      mperm@.wf_not_null_at(0x1000),      mperm@.is_vmpl0_private(){    let val1 = *borrow(0x1000, Tracked(mperm));    let val2 = *borrow(0x1000, Tracked(mperm));    assert(val2 == val1);    replace(0x1000, 0x1234, Tracked(mperm)); // Rust : change the unmutable val!    let _val3 = *borrow(0x2000, Tracked(mperm)); // Verus: borrow wrong addr!}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 unsafe rust 操作，我们用 verus 来限制并验证其使用，比如 <code>rmpadjust</code> 指令，就有复杂的前置和后置条件（见 <a href="https://verus-lang.github.io/verus/guide/memory-safety.html">19.2. Memory safety is conditional on verification</a>）：</p><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">pub fn rmpadjust(    vaddr: u64,    psize: u64,    attr: RmpAttr,    Tracked(mycore): Tracked&lt;&amp;SnpCore&gt;,    Tracked(newcore): Tracked&lt;Option&lt;CoreIdPerm&gt;&gt;,    Tracked(perm): Tracked&lt;&amp;mut SnpPointsToRaw&gt;,) -&gt; (ret: u64)    requires        old(perm)@.snp().requires_rmpadjust(vaddr as int, psize as int, attr@, newcore, old(perm)@),        mycore.coreid@.vmpl == 0,        attr.spec_vmpl() &gt; mycore.coreid@.vmpl,    ensures        old(perm)@.snp.rmpadjust_ret(perm@.snp, ret, vaddr as int, psize as int, attr@),        old(perm)@.range() === perm@.range(),        old(perm)@.snp_bytes === perm@.snp_bytes,{    let ret: u64;    unsafe {        asm!(".byte 0xf3,0x0f,0x01,0xfe",                in("rax") vaddr, in("rcx") psize, in("rdx") attr.value,                lateout("rax") ret,                options(nostack));    }    ret}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>PS: <code>@</code> 是 <code>.view()</code> 的缩写，见 <a href="https://verus-lang.github.io/verus/guide/reference-at-sign.html">4.1. Recursive spec functions, decreases, fuel</a></p></blockquote><p>其中 SNP Pointer 和与之配套的验证约束合称 Memory Permisson，因为这种 Permission 有时是需要共享的（因为内存需要共享），所以又引入了 Lock Permisson 来确保并发程序的正确性。</p><p><img src="/posts/71c079c7/1722216970526-19.png" alt="img"></p><p>VeriSMo 内存并发安全模型为：</p><ol><li>上锁的 VMPL0 私有内存（可信内存）可以任意访问；</li><li>如果其他实体（VMPL3 或者 HV）想共享给 VMPL0，要么上锁后拷贝给 VMPL0，要么修改映射关系后重新写入；</li><li>如果 VMPL0 需要共享给其他实体，可以上锁后直接修改映射关系。</li></ol><hr><h2 id="四、信息流安全验证"><a href="#四、信息流安全验证" class="headerlink" title="四、信息流安全验证"></a>四、信息流安全验证</h2><p>左图中，机密变量 high 被通过数据流泄露到公开变量 low。右图中，机密变量 high 通过控制流侧信道被泄露。</p><p><img src="/posts/71c079c7/1722216998108-26.png" alt="img"></p><p>具体的，本工作记录 VeriSMo 中每个变量的猜测空间（guess space, valset），猜测空间为全集的变量为机密变量，猜测空间为单元素集合的变量为公开变量，猜测空间随着计算操作传播。</p><p><img src="/posts/71c079c7/1722216998109-27.png" alt="img"></p><p>验证器确保：</p><ol><li>只有机密变量能用作密钥，</li><li>机密变量保存在 VMPL0 私有内存中</li><li>机密变量不能用于控制流判断、内存地址等可能导致侧信道泄露的用途。</li></ol><hr><h2 id="五、实现与评估"><a href="#五、实现与评估" class="headerlink" title="五、实现与评估"></a>五、实现与评估</h2><p>从实现层面来说，似乎锁设计比较新颖，锁的数目比较少，验证难度也比较低。</p><p>从实现性能看，与 Hecate 这种提供安全服务的 HV 相比，性能提高了 40%，因为不需要频繁内陷到 HV 中，这应该是所有的 Secure Module 都具有的性能优势。</p><p>而与其他的 Secure Module 相比（用 C 实现的 SMo 或者修改后 Linux 作为一个 SMo），在性能开销方面差别不大（Index 越高性能越好）</p><p><img src="/posts/71c079c7/1722217009985-32.png" alt="img"></p><p>从验证层面看，验证速度很快，大约 6 分钟就可以验证完两层模型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/posts/71c079c7/1600x900_1591431860952_2048x1152_logo.jpg&quot; alt=&quot;A RaiPlay learning il Verismo e i suoi autori - RAI Ufficio Stampa&quot;&gt;&lt;/p&gt;
&lt;p&gt;VeriSMo 的可信基只包括硬件和它自己（VM），剔除了对于 Hypervisor 的信任。传统的 VM 的安全服务是由 Hypervisor 负责的，如果认为 Hypervisor 是不可信的，那么就不能由它来提供安全服务。AMD 提供了新的安全架构 SEV-SNP，它为在 VM 中独立实现安全服务提供了支持，VeriSMO 就利用了这个硬件特性。&lt;/p&gt;
&lt;p&gt;除了利用新的硬件安全特性外，VeriSMo 在开发时完成了形式化验证来确保安全性。VeriSMo 的开发语言是 Rust，已经确保了部分的内存安全性（也就是 Rust Checker 承担了部分形式化验证的任务），距离完全的形式化验证还有两个挑战：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为 Hypervisor 不可信任，所以 Hypervisor 可以打断 VM 的执行并修改硬件状态，这种并行无法简单验证。&lt;/li&gt;
&lt;li&gt;开发 VeriSMo 需要使用 Unsafe Rust，Rust Checker 无法验证这种情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决挑战 1，VeriSMo 将验证拆分成了 2 层，上层为机器模型层（Machine Model），用 model verify 专门约束 Hypervisor 的行为，下层为实现层（Implement），用于解决排除了 Hypervisor 干扰后的 VeriSMo 本身的验证问题。&lt;/p&gt;</summary>
    
    
    
    <category term="海边拾贝" scheme="https://thysrael.github.io/categories/%E6%B5%B7%E8%BE%B9%E6%8B%BE%E8%B4%9D/"/>
    
    
    <category term="知识总结" scheme="https://thysrael.github.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    <category term="S8假期" scheme="https://thysrael.github.io/tags/S8%E5%81%87%E6%9C%9F/"/>
    
    <category term="海边拾贝" scheme="https://thysrael.github.io/tags/%E6%B5%B7%E8%BE%B9%E6%8B%BE%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>信息安全-基本概念</title>
    <link href="https://thysrael.github.io/posts/7efac32a/"/>
    <id>https://thysrael.github.io/posts/7efac32a/</id>
    <published>2024-07-10T12:51:28.000Z</published>
    <updated>2024-10-17T06:35:01.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安全目标"><a href="#一、安全目标" class="headerlink" title="一、安全目标"></a>一、安全目标</h2><h3 id="1-1-总论"><a href="#1-1-总论" class="headerlink" title="1.1 总论"></a>1.1 总论</h3><p>系统安全有 3 个目标：</p><ul><li><strong>机密性（Confidentiality）</strong>：又称隐私性（Privacy），是指数据不能被未授权的主体窃取（即恶意读操作）。</li><li><strong>完整性（Integrity）</strong>：是指数据不能被未授权的主体篡改（即恶意写操作）。</li><li><strong>可用性（Availability）</strong>：是指数据能够被授权主体正常访问。</li></ul><p>合称 CIA 。</p><h3 id="1-2-机密性-Confidentiality"><a href="#1-2-机密性-Confidentiality" class="headerlink" title="1.2 机密性 (Confidentiality)"></a>1.2 机密性 (Confidentiality)</h3><h4 id="1-2-1-含义"><a href="#1-2-1-含义" class="headerlink" title="1.2.1 含义"></a>1.2.1 含义</h4><p>完整性是指保护数据不被未授权的主体篡改，确保数据的准确性、一致性和信任度。</p><h4 id="1-2-2-实现手段"><a href="#1-2-2-实现手段" class="headerlink" title="1.2.2 实现手段"></a>1.2.2 实现手段</h4><ul><li><strong>加密</strong>：对数据进行加密，只有持有正确解密密钥的主体才能读取数据。</li><li><strong>访问控制</strong>：通过访问控制列表（ACL）和权限设置来限制数据的访问。</li><li><strong>身份验证</strong>：确保数据只能由经过身份验证的用户或系统访问。</li></ul><h4 id="1-2-3-示例"><a href="#1-2-3-示例" class="headerlink" title="1.2.3 示例"></a>1.2.3 示例</h4><ul><li><strong>加密通信</strong>：使用 HTTPS 协议对网络通信进行加密，防止第三方窃取传输中的数据。</li><li><strong>数据加密存储</strong>：在文件系统或数据库中对敏感信息进行加密存储。</li><li><strong>访问控制</strong>：设定文件或数据库记录的访问权限，只允许具备相应权限的用户访问。</li></ul><h3 id="1-3-完整性-Integrity"><a href="#1-3-完整性-Integrity" class="headerlink" title="1.3 完整性 (Integrity)"></a>1.3 完整性 (Integrity)</h3><h4 id="1-3-1-含义"><a href="#1-3-1-含义" class="headerlink" title="1.3.1 含义"></a>1.3.1 含义</h4><p>完整性是指保护数据不被未授权的主体篡改，确保数据的准确性、一致性和信任度。</p><h4 id="1-3-2-实现手段"><a href="#1-3-2-实现手段" class="headerlink" title="1.3.2 实现手段"></a>1.3.2 实现手段</h4><ul><li><strong>校验和和哈希</strong>：使用校验和或哈希函数来生成数据的唯一摘要，接收方可以通过比较摘要来验证数据是否被篡改。</li><li><strong>数字签名</strong>：使用数字签名对数据进行签名，以确保数据在传输中的完整性和来源的可靠性。</li><li><strong>版本控制</strong>：使用版本控制系统记录数据的变更历史，防止未经授权的修改。</li></ul><h4 id="1-3-3-示例"><a href="#1-3-3-示例" class="headerlink" title="1.3.3 示例"></a>1.3.3 示例</h4><ul><li><strong>哈希校验</strong>：下载文件后检查文件的哈希值，确认其未被篡改。</li><li><strong>数字签名</strong>：邮件或文档使用数字签名，收件人可以验证其来源和内容的完整性。</li><li><strong>文件权限</strong>：设置敏感文件为只读，防止未经授权的用户进行修改。</li></ul><h3 id="1-4-可用性-Availability"><a href="#1-4-可用性-Availability" class="headerlink" title="1.4 可用性 (Availability)"></a>1.4 可用性 (Availability)</h3><h4 id="1-4-1-含义"><a href="#1-4-1-含义" class="headerlink" title="1.4.1 含义"></a>1.4.1 含义</h4><p>可用性是指确保数据和系统在需要时能够被授权的主体正常访问和使用。</p><h4 id="1-4-2-实现手段"><a href="#1-4-2-实现手段" class="headerlink" title="1.4.2 实现手段"></a>1.4.2 实现手段</h4><ul><li><strong>冗余和备份</strong>：通过数据冗余和定期备份来确保数据在特殊情况下（如硬件故障）仍然可用。</li><li><strong>容错和高可用架构</strong>：设计容错和高可用系统架构，使用负载均衡、多路径等技术，确保系统在故障情况下仍然能够提供服务。</li><li><strong>DoS/DDoS 保护</strong>：通过防火墙、入侵检测系统（IDS）和流量管理等手段防止拒绝服务（DoS）或分布式拒绝服务（DDoS）攻击。</li></ul><h4 id="1-4-3-示例"><a href="#1-4-3-示例" class="headerlink" title="1.4.3 示例"></a>1.4.3 示例</h4><ul><li><strong>云备份</strong>：定期将数据备份到云存储，确保在本地数据损坏时可以恢复。</li><li><strong>高可用性集群</strong>：使用高可用性集群和负载均衡器分配流量，确保一个节点出现故障时，其他节点可以继续提供服务。</li><li><strong>流量管理</strong>：部署防火墙和负载均衡器，防止由于流量异常导致的服务中断。</li></ul><h3 id="1-5-三者的区别"><a href="#1-5-三者的区别" class="headerlink" title="1.5 三者的区别"></a>1.5 三者的区别</h3><ul><li><strong>机密性 vs. 完整性</strong>：机密性关注的是防止数据被窃取，而完整性关注的是数据未经授权被篡改。机密性主要解决“谁能看到”的问题，而完整性解决的是“它是否被改变”的问题。</li><li><strong>完整性 vs. 可用性</strong>：完整性确保数据的准确和一致性，而可用性确保数据和系统在需要时是可访问的。完整性保证数据未受未经授权的修改，可用性保证在正确时间提供正确的服务。</li><li><strong>机密性 vs. 可用性</strong>：在某些情况下，机密性和可用性可能需要权衡。例如，高度加密的数据可能需要更多的计算资源解密，从而影响系统的可用性。机密性和可用性关注的是不同的方面，前者注重安全访问，后者注重无障碍访问。</li></ul><hr><h2 id="二、访问控制"><a href="#二、访问控制" class="headerlink" title="二、访问控制"></a>二、访问控制</h2><h3 id="2-1-总论"><a href="#2-1-总论" class="headerlink" title="2.1 总论"></a>2.1 总论</h3><p>访问控制（Access Control）是按照访问主体的身份（Identity）来限制其访问对象的一种方法。它由两个基本过程组成，即：</p><ul><li>认证（Authentication）：验证某个发起访问请求的主体的身份。</li><li>授权（Authorization）：授予某个身份一定的权限以访问特定的对象。</li></ul><p>访问控制是这样的一件事，资源的请求方被称为主体，认证干的事情是确定你真的是这个主题，而不是一个人化妆了伪造出来的人，换句话说，认证干的是“主体 =&gt; 身份”的工作；授权则干得是“身份 =&gt; 权限”的工作，需要强调，授权并不只局限于“赋予”某个身份一定的权限，他还包括这个权限的正确执行，违法权限的行为的发现。</p><p><img src="/posts/7efac32a/image-20240711145910684.png" alt="image-20240711145910684"></p><p>打给比方，认证就是“火眼金睛”，而“授权”则是天条和天兵。</p><h3 id="2-2-认证"><a href="#2-2-认证" class="headerlink" title="2.2 认证"></a>2.2 认证</h3><p>认证过程旨在建立发起请求的主体与系统中某个 ID 之间的绑定关系。例如，用户登录操作系统时，首先要选择用户名（即 ID），然后输入密码或口令完成登录过程。</p><p>认证过程中,判断某一个主体身份的方法主要有三种：</p><ul><li>你知道什么（Something you know）：例如密码/口令（password）、手势密码、某个问题的答案等。</li><li>你有什么（Something you have）：例如 USB-key、密码器等实物；电子令牌（token）</li><li>你是什么（Something you are）：例如指纹、虹膜、步态、键盘输入习惯等，属于人的一部分。</li></ul><p>总的来说，由上到下主体和身份（ID）的相关性在增强，进而安全性就在增强。主体知道的东西很容易被窃取，比如一个用生日做的密码，即使不是主体，也很容猜到。而主体的指纹，就没那么容易搞到了。</p><p>Token 和 Password 都用于身份验证但用途和特性不同。Password 是用户在登录时输入的静态字符组合，用于初次验证身份。而 Token 则是在用户通过密码验证后，由服务器生成并发给客户端的动态凭证，用于在后续请求中证明身份。与 Password 不同，Token 通常有时效性，可以减少频繁传递 Password 的安全风险，并且适合分布式系统中的认证场景。</p><h3 id="2-3-授权"><a href="#2-3-授权" class="headerlink" title="2.3 授权"></a>2.3 授权</h3><p>授权，是判断某个主体是否有权限访问某个对象的过程。授权机制主要考虑以下三个问题：</p><ol><li><p><strong>用何种数据结构来表达主体与对象之间的权限关系</strong>：</p><p>确定如何存储和表示主体与对象之间的权限关系，如使用访问控制列表（ACL）、角色权限矩阵或权限表等。</p></li><li><p><strong>如何设置和修改这种权限关系</strong>：</p><p>确定权限的分配和调整机制，例如通过管理员手动配置、角色分配系统或自动化策略等。</p></li><li><p><strong>如何强制保证这种权限关系</strong>：</p><p>确保系统能够正确执行权限检查和访问控制，防止未经授权的访问。可以通过身份验证、访问控制检查和安全审计等手段来实现。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、安全目标&quot;&gt;&lt;a href=&quot;#一、安全目标&quot; class=&quot;headerlink&quot; title=&quot;一、安全目标&quot;&gt;&lt;/a&gt;一、安全目标&lt;/h2&gt;&lt;h3 id=&quot;1-1-总论&quot;&gt;&lt;a href=&quot;#1-1-总论&quot; class=&quot;headerlink&quot; title=&quot;1.1 总论&quot;&gt;&lt;/a&gt;1.1 总论&lt;/h3&gt;&lt;p&gt;系统安全有 3 个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机密性（Confidentiality）&lt;/strong&gt;：又称隐私性（Privacy），是指数据不能被未授权的主体窃取（即恶意读操作）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完整性（Integrity）&lt;/strong&gt;：是指数据不能被未授权的主体篡改（即恶意写操作）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性（Availability）&lt;/strong&gt;：是指数据能够被授权主体正常访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合称 CIA 。&lt;/p&gt;</summary>
    
    
    
    <category term="信息安全" scheme="https://thysrael.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="信息安全" scheme="https://thysrael.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="S8假期" scheme="https://thysrael.github.io/tags/S8%E5%81%87%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>沟通交流-旋氏语法</title>
    <link href="https://thysrael.github.io/posts/a039c29c/"/>
    <id>https://thysrael.github.io/posts/a039c29c/</id>
    <published>2024-06-24T01:58:10.000Z</published>
    <updated>2024-10-17T06:35:03.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><p>这篇文章是对于<a href="https://llwslc.github.io/grammar-club/">旋元佑语法俱乐部</a>的一个注释总结。行文思路基本上和这本电子书的章节保持一致。</p><p>语法是对于语言的规律总结，这类似于物理是对于客观世界的规律总结。不过应当注意到，即使掌握了语法，也并不能短时间内提高英语水平，因为在语法的指导下使用语言，同样是一个需要习惯和精进的过程。这就像掌握了物理定律和物理满分之间依然存在很大差距一样。</p><p>旋老师的语法和我中学学过的语法并不一样，旋老师倾向于建立一种“大一统”的理论来解释所有的语言现象，而中学语法则更加繁杂和缺少一致性。在加上我这次学习语法已经是大四，在逻辑思维上相比于中学已经有了很大的进步。所以总的来说，语法更加“讲理”了。</p><p>但是旋氏语法的缺点我个人感觉有两个，一个是因为过于“统一”，导致需要引入一堆与中学语法似是而非的概念，这些概念类似于物理学上的“波粒二象性”一样，对中学语法是一种挑战；并且因为旋老师是台湾人的缘故，所以在表达习惯和方式上也与大陆存在一定的差异（也就是他写的中文有点难看懂）。另一个是旋老师在建立了“统一”的理论后，并没有充分利用这些规律推导出中学语法甚至是其他中学语法难以推导的其他语言现象。</p><p>所以这篇文章会对原本的电子书进行一定的解释和应用。</p><hr><h2 id="二、简单句"><a href="#二、简单句" class="headerlink" title="二、简单句"></a>二、简单句</h2><h3 id="2-1-基本句型"><a href="#2-1-基本句型" class="headerlink" title="2.1 基本句型"></a>2.1 基本句型</h3><p>英语语法的研究单位是句子，而简单句（可以看作比较本源的一种句子）一共有  5 种句型，如下所示：</p><div class="table-container"><table><thead><tr><th>简记</th><th>解释</th><th>动词性质</th><th>举例</th></tr></thead><tbody><tr><td>S + V</td><td>主语 + 动词</td><td>不及物动词</td><td>die, smile</td></tr><tr><td>S + V + O</td><td>主语 + 动词 + 宾语</td><td>单宾语及物动词</td><td>kill, love, like</td></tr><tr><td>S + V + C</td><td>主语 + 动词 + 主语补语</td><td>系动词/连缀动词</td><td>be, seem, sound, feel, prove</td></tr><tr><td>S + V + O + O</td><td>主语 + 动词 + 直接宾语 + 间接宾语</td><td>双宾语及物动词</td><td>give, call,tell</td></tr><tr><td>S + V + O + C</td><td>主语 + 动词 + 宾语 + 宾语补语</td><td>宾语补语及物动词</td><td>find, consider, find</td></tr></tbody></table></div><p>其中简记符号是这样的：</p><div class="table-container"><table><thead><tr><th>符号</th><th>英文</th><th>全称</th></tr></thead><tbody><tr><td>S</td><td>Subject</td><td>主语</td></tr><tr><td>V</td><td>Verb</td><td>动词</td></tr><tr><td>O</td><td>Object</td><td>宾语</td></tr><tr><td>C</td><td>Complement</td><td>补语</td></tr></tbody></table></div><p>在这种分类下（其实这只是旋老师自己的分类，有些语法的分类要更加复杂），有许多有趣的特征：</p><p>可以看到这种对句子成分的分类法，取消了常见的“谓语，状语，表语”的语法成分。其中谓语的取消，应该是因为谓语的定义过于宏大。谓语的英文是 Predicate，也就是断言，所以我个人理解，断言加上断言的目标，也就是主语，那么就可以构成一个命题了，而命题基本上是句子存在的意义。我们说的每一句话，都是一个命题。如果认为句子中存在谓语，那么基本上其他的语法成分都会被囊括其中，其实是不利于细致探究的。而状语之所以没有，是因为它并不是句子的主干，而是句子的点缀，所以就没有细说。而传统意义上的表语，则大部分被划分到了补语范畴内，旋老师这么做是为了某种“简洁性”。</p><p>一个句子对应一个动词。也就是说，如果一个字符串里没有动词，那么就一定不是一个简单句，同理，如果一个字符串中有了两个动词，那么就一定不是一个简单句，而有可能是一个从句，或者简化从句，这是很有意思的一点，比如说例句：</p><blockquote><p>I hate programming.</p></blockquote><p>其中有 hate 和 program 两个动词，所以它并不是一个简单句，而是一个简化从句：</p><blockquote><p>I hate that I program.</p></blockquote><p>意识到句子与动词的一一对应关系，可以理解复杂的句子，因为动词很好数出来。</p><p>动词的性质决定了不同的句型。上文列出了五种句型，并不是可以随意搭配动词使用的。动词性质决定了句型，比如不及物动词，它的句型只能是“S + V”，不能是“S + V + C”。所以积累动词的性质，可以有助于我们识别句子的结构，当遇到一个不及物动词的时候，就不用去后文找补语或者宾语了。</p><h3 id="2-2-限定"><a href="#2-2-限定" class="headerlink" title="2.2 限定"></a>2.2 限定</h3><p>在介绍其他语法之前我想介绍一下限定（Finite），它指的是词语的一种属性。对于动词而言，简单句里的动词都是限定动词，这样的动词需要受到人称、时态、语态、助词（情态动词等）、语气的限制（Determiner），也就是承担了更多的句子表达更多信息的任务。我们可以从限定动词中获得更多的信息，在使用限定动词的时候，也需要注意更多限制。而非限定动词则不需要考虑那么多，一般只有 Ving，to V，Ven 这几种形式。非限定动词可以看作是从句简化后的结果。</p><p>基于“限定”的概念，引申出来“不定式”的概念，它特指“to V”结构。旋老师将不定时描述成了情态动词的退化，将在后面详述。</p><p>除了动词以外，名词也有限定词的说法，它指的是复数变化和冠词等内容。</p><h3 id="2-3-时态"><a href="#2-3-时态" class="headerlink" title="2.3 时态"></a>2.3 时态</h3><h4 id="2-3-1-分词"><a href="#2-3-1-分词" class="headerlink" title="2.3.1 分词"></a>2.3.1 分词</h4><p>在传统语法中，时态是非常复杂的，有如此多项：</p><ul><li>时间：过去，现在，未来</li><li>状态：简单，进行，完成</li><li>语态：主动，被动</li></ul><p>一般都是这三种内容的自由组合，比如说“过去完成时被动语态”。旋老师主张将进行时和被动语态看作一种“形容词”，这样</p><blockquote><p>I am reading.</p></blockquote><p>就变成了一种“S + V + C”的结构。这样的话，其实就取消了“主被动”的问题，并且减少了“状态”中的进行时。这种简化我觉得并不是很有意义，只是在形式上简化了语法，但是“进行”或者“被动”本身的含义并没有被化简掉。</p><p>这种思想其实并不是牵强附会，它可以看作是“分词 Participle”思想的延伸，分词既有动词的特性，也有形容词的特性，所以说它”分享”了两种词类的特点。分词有现在分词（Present Participle）和过去分词（Past Participle）两种，其实就是 Ving 和 Ved 这两种。它们原本是动词，分词化处理后具有了形容词词性，所以可以担任补语的职责。</p><h4 id="2-3-2-状态"><a href="#2-3-2-状态" class="headerlink" title="2.3.2 状态"></a>2.3.2 状态</h4><p>其中时间和语态的区分是比较容易的，难点还是状态的区分上。我感觉最好还是同时区分“简单、进行、完成”三种语态。其实从语义上来说，三者的区别是很明显的，其中普通式指的是“这句话只是为了说这句话”，也就是这句话就是一个纯粹的<strong>命题</strong>。其他两种状态都有一种“这句话是别的话的铺垫”的感觉，这是我觉得这三种状态最核心的区别，如下所示：</p><blockquote><p>I read this book. （我读这本书，平平淡淡的陈述句）</p><p>I am reading this book （我正在读这本书，强调“正在”要超过“读”，可能表明现在很忙）</p><p>I have read this book （我读过这本书了，强调“读过”要超过“读”，可能表明我了解这本书的知识了）</p></blockquote><p>当然在搞明白这点以后，其实并不足够。我个人感觉是因为状态的描述不仅需要依靠现在分词或者 have 这样的助动词来帮助，它们往往和时间概念联系在一起。这并不奇怪，因为当我们在说一个不是纯粹命题的句子（也就是普通式）的时候，我们往往还要说些其他的信息，而将不纯粹命题和其他信息联系在一起的媒介，就是时间。比如说：</p><blockquote><p>I was reading this book when he knocked my door. （他的敲门打扰了我“正读书”的行为）</p><p>I have read this book so that I will pass the exam easily. （因为我“读过”书了，所以通过考试对我轻轻松松） </p></blockquote><p>这些蕴藏在状态中的时间概念，如下图所示：</p><p><img src="/posts/a039c29c/time.png" alt=""></p><p>对于普通式来说，其时间观念的核心在于一个“<strong>有始有终的准确时间范围</strong>”，这是因为任何命题的成立都需要一个时间范围。比如：</p><blockquote><p>I read this book last week.</p></blockquote><p>这句话如果去掉了“last week”也不是不行，但是这只是一种“省略”，但是读书一定会发生在过去的一个准确的时间段。这种时间段有两个有趣的特性。一个就是前面提到的省略，确实可以省略，但是意思并不会变，与之形成对比就是其他两种状态，往往更需要显式的时间成分。另一个就是时间段的开始和结束时间可以到无限远，此时命题就变成了真理。</p><p>当时间段缩短到一个点的时候，就得到了进行时，这个很好理解。</p><p>而完成时更容易和普通式弄混，如前所述，完成时强调的不再是命题本身，而是命题之外的信息。所以命题发生的时间并不重要，命题产生影响的时间更重要。所以它在示意图中是一个单向箭头，箭头的起点是受到命题影响的时间，而不是命题发生的时间。比如：</p><blockquote><p>I have read this book.</p></blockquote><p>即使这句话使用了“现在”完成时，但是主人公并不是在现在读的书，而是在过去的某个时间节点读的书，只是“现在”要用上这本书的知识了。所以完成时和普通时的一个更加形而下的差别，就是完成时不能确定命题的开始时间和结束时间。</p><p>上面细化了状态的时间概念，但是是从一个比较抽象的、感性的层次去描述的，而实际上，抽象的时间概念依然会落实到具体的单词或者句子上，这些具体的单词或者句子，其实都很有标示性，这就像汉语中很难跳过“正在”或者“过”来描述进行时和完成时一样。故总结如下：</p><div class="table-container"><table><thead><tr><th>状态</th><th>短语</th></tr></thead><tbody><tr><td>普通式</td><td>in + 时间点，this/next month</td></tr><tr><td>进行式</td><td>whole + 时间段，when 从句，then</td></tr><tr><td>完成式</td><td>for + 时间段，since 从句，before 从句，by the time 从句</td></tr></tbody></table></div><h3 id="2-4-语气"><a href="#2-4-语气" class="headerlink" title="2.4 语气"></a>2.4 语气</h3><h4 id="2-4-1-助动词"><a href="#2-4-1-助动词" class="headerlink" title="2.4.1 助动词"></a>2.4.1 助动词</h4><p>在介绍语气前还需要介绍一下助动词（Auxiliary Verb），他们是一种类似于“名词，动词，副词”这样的独立词性。正如前面“限定”所介绍的，限定动词需要承担描述许多信息的职责，当 Ving，Ved 无法满足表达需要的时候，助动词就会出现来辅助限定动词的表达。助动词有如下几类：</p><ul><li>be</li><li>have</li><li>do</li><li>情态动词（modal）</li></ul><h4 id="2-4-2-真假"><a href="#2-4-2-真假" class="headerlink" title="2.4.2 真假"></a>2.4.2 真假</h4><p>语气其实也应该合在“时态”章节里介绍，他们都属于某种“限定”，只是我之前一直忽视，就单独拿出来讲了。语气解决的问题是不再让句子称为一个只是布尔值的情况，他让命题的真值更加连续：</p><blockquote><p>You may be right.</p></blockquote><p>这句话并不能说明”你是对的“，而只能说是可能正确。这种限定句子”真假“的语气，一共有 3 种：</p><ul><li>推测：表示对于命题的不确定（可能学名不叫这个，但是我觉得这个恰当）</li><li>虚拟：表示一种不可能的情况，用说反话的方式来表达意思</li><li>祈使：表示希望能成真，但尚未实现</li></ul><h4 id="2-4-3-推测"><a href="#2-4-3-推测" class="headerlink" title="2.4.3 推测"></a>2.4.3 推测</h4><p>推测语句表示的是一种”不确定“的语气，它需要加上情态动词（must、should、will/would、can/could、may/might 等）来完成。</p><blockquote><p>You are right. （你是对的。）</p><p>You may be right. （你可能是对的。）</p></blockquote><p>需要注意的是，would，could，might 虽然是 will，can，may 的过去时，但是我们并不能用它们表示”过去推测“，他们只是表示一种相对于现在时更加不确定的语气：</p><blockquote><p>The doctor thinks it <strong>can be</strong> AIDS. （医生认为可能是艾滋病。）</p><p>It <strong>could be</strong> anything—AIDS or a common cold. （还看不出来是什么病——可能是艾滋病，也可能是感冒。）</p></blockquote><p>这种现象导致按照过去的逻辑，推测语气是只有现在时的，没有时态变化的。因为在过去时所需要的 would/could/might 都被当成了一种“更小概率”的语义，而将来时所需要的 will，也被当成了一种“概率”的语义。</p><p>但是显然推测语气是需要和时态组合的，它们拓展了原本的规则，总结如下：</p><div class="table-container"><table><thead><tr><th>时态</th><th>用法</th><th>例子</th></tr></thead><tbody><tr><td>过去时</td><td>情态动词 + have + Ved</td><td>It <strong>may have rained</strong> a little last night.</td></tr><tr><td>现在时</td><td>情态动词 + V</td><td>It <strong>may rain</strong> any minute now.</td></tr><tr><td>将来时</td><td>情态动词 + V</td><td>It <strong>may rain</strong> tomorrow.</td></tr></tbody></table></div><p>总的来说就是用完成式表达过去时，而用普通式表达现在和将来。</p><h4 id="2-4-4-虚拟"><a href="#2-4-4-虚拟" class="headerlink" title="2.4.4 虚拟"></a>2.4.4 虚拟</h4><p>虚拟语气在描述一种“假如”语义，是一种复句语义，即“假如……，那么就……”。首先声明，这里说的“假如”，并不是全部的“条件句”，而是条件句的一类。有些条件句真的是在描述一种命题推导关系，比如说</p><blockquote><p>If you let go, the apple will fall.</p></blockquote><p>这是一个地球上的客观事实，只要你松手（条件），苹果就会掉落（结果），没有人限制你是否松手。但是还有一种条件句，它是一种“假如”的语气，也就是“假如，我说得是假如啊”，这是一个不可能发生的条件：</p><blockquote><p> If I were you, I wouldn’t do it. </p></blockquote><p>显然“我不是你”，所以条件并不成立。这是在说反话。还有一种翻译是“万一”：</p><blockquote><p>If an asteroid <strong>should hit</strong> the earth, man <strong>could die</strong> out.</p></blockquote><p>将其翻译成“万一小行星撞击地球了，那么人们可能就灭绝了”也是非常得体的。</p><p>在介绍具体的虚拟语气语法现象之前，我想先理清一下条件句的结构，其实只有两个部分，一个是条件句，一个是结论句。以此句举例：</p><blockquote><p> If I were you, I wouldn’t do it. </p></blockquote><p>其中“如果我是你”这是条件句，而“我不会做这件事”是结论句。那么为了达成这种“虚拟语气”，是条件句需要调整，还是结论句需要调整？答案是基本上都需要调整，或者严谨的说：<strong>无论条件句还是结论句是涉及了“虚拟，假如”的语义，那么就都需要变化，而条件句和结论句的变化方式是不同的</strong>。变化方式总结如下：</p><div class="table-container"><table><thead><tr><th>时态</th><th>条件句（从句）</th><th>结论句（主句）</th></tr></thead><tbody><tr><td>过去时</td><td>had + Ved</td><td>would/could /might + have + Ved</td></tr><tr><td>现在时</td><td>Ved（其中如果是 be 要变成 were）</td><td>would/could /might + V</td></tr><tr><td>将来时</td><td>should/were to + V</td><td>would/could /might + V</td></tr></tbody></table></div><p>在传统语法中，会归纳出“时态回退”现象，也就是“过去时变成过去完成时，现在时变成过去时，将来时情态动词变成 should”，可以看到这种规律即使用在条件句上，也会显得牵强，而用在结论句上，则是完全不符合。所以我主张直接记忆这个表格。</p><p>需要注意，在实际使用中，存在“时态错综”现象，也就是说，可以存在一个句子，具有过去时的条件句，而具有现在时的结论句，如下所示：</p><blockquote><p>If I <strong>had studied</strong> harder <strong>in school</strong>（过去）, I <strong>could qualify</strong> for the job <strong>now</strong>（现在）.</p></blockquote><p>此外，甚至“真假”也可以错综，也就是一个真实的条件句搭配一个虚拟语气的结论句，比如说：</p><blockquote><p>I <strong>could have contributed</strong> to the fund drive then（虚拟，我本来想捐钱但是并没有捐）, only that I <strong>didn’t have</strong> any money with me（真实，我真的没有带钱）.</p></blockquote><p>最后补充一下真实条件句的时态变化，其实只有一点，就是真实条件句一般都是“主将从现”的。这是因为如果条件发生在过去，那么结论一般已经发生了，那么就不构成这种“条件推导”关系了（硬币落下后再猜正反没有意义了，坍缩了）。而条件如果发生在将来，那么也没啥意义，因为对将来一无所知，我们能做的是就是根据现在的条件，判断未来发生的事情。</p><h4 id="2-4-5-祈使"><a href="#2-4-5-祈使" class="headerlink" title="2.4.5 祈使"></a>2.4.5 祈使</h4><p>祈使语气最简单了，就是直接用动词原型，然后省略主语。</p><p>还有一种间接祈使句，就是祈使句的命令方并非听着，而是第三者，这样就会呈现这样的例子：</p><blockquote><p>The court demands that the witness <strong>leave</strong> the courtroom. </p><p>There is a strong expectation among the public that someone <strong>take</strong> responsibility for the disaster.</p></blockquote><p>我很想积累这些固定用法，但是时间有些紧张。按照旋老师的说法，固定用法有很多，最重要的是看重祈使语气所强调的“望能成真，但尚未实现”。</p><h3 id="3-冠词"><a href="#3-冠词" class="headerlink" title="3. 冠词"></a>3. 冠词</h3><p>冠词 a(n) 可以视为 one 的弱化（reduction）结果。也就是说，a(n) 就代表 one 的意思，只是语气比较弱。</p><p>the 可视为 that 或 those 的弱化形式。而 that 或 those 是指示形容词，有明确的指示功能。所以定冠词 the 也可以用同样的角度来了解：凡是上下文中有明指或暗示时，也就是有“那个”的指示功能时，便要用定冠词 the。</p><hr><h2 id="三、复合句及其化简"><a href="#三、复合句及其化简" class="headerlink" title="三、复合句及其化简"></a>三、复合句及其化简</h2><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、总论&quot;&gt;&lt;a href=&quot;#一、总论&quot; class=&quot;headerlink&quot; title=&quot;一、总论&quot;&gt;&lt;/a&gt;一、总论&lt;/h2&gt;&lt;p&gt;这篇文章是对于&lt;a href=&quot;https://llwslc.github.io/grammar-club/&quot;&gt;旋元佑语法俱乐部&lt;/a&gt;的一个注释总结。行文思路基本上和这本电子书的章节保持一致。&lt;/p&gt;
&lt;p&gt;语法是对于语言的规律总结，这类似于物理是对于客观世界的规律总结。不过应当注意到，即使掌握了语法，也并不能短时间内提高英语水平，因为在语法的指导下使用语言，同样是一个需要习惯和精进的过程。这就像掌握了物理定律和物理满分之间依然存在很大差距一样。&lt;/p&gt;
&lt;p&gt;旋老师的语法和我中学学过的语法并不一样，旋老师倾向于建立一种“大一统”的理论来解释所有的语言现象，而中学语法则更加繁杂和缺少一致性。在加上我这次学习语法已经是大四，在逻辑思维上相比于中学已经有了很大的进步。所以总的来说，语法更加“讲理”了。&lt;/p&gt;
&lt;p&gt;但是旋氏语法的缺点我个人感觉有两个，一个是因为过于“统一”，导致需要引入一堆与中学语法似是而非的概念，这些概念类似于物理学上的“波粒二象性”一样，对中学语法是一种挑战；并且因为旋老师是台湾人的缘故，所以在表达习惯和方式上也与大陆存在一定的差异（也就是他写的中文有点难看懂）。另一个是旋老师在建立了“统一”的理论后，并没有充分利用这些规律推导出中学语法甚至是其他中学语法难以推导的其他语言现象。&lt;/p&gt;</summary>
    
    
    
    <category term="沟通交流" scheme="https://thysrael.github.io/categories/%E6%B2%9F%E9%80%9A%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="知识总结" scheme="https://thysrael.github.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="沟通交流" scheme="https://thysrael.github.io/tags/%E6%B2%9F%E9%80%9A%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>吃喝玩乐-流浪天津</title>
    <link href="https://thysrael.github.io/posts/cb9fcc81/"/>
    <id>https://thysrael.github.io/posts/cb9fcc81/</id>
    <published>2024-06-20T12:11:21.000Z</published>
    <updated>2024-10-17T06:35:02.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于“死猪不怕开水烫”这句话，似乎每个人的理解是不同的：</p><p>有的人是“小太爷告诉你，咱得是猪，可不是那鸡鸭的便宜玩意儿”；</p><p>有的人是“跟嫩么说，别听前面的猪渍歪，介玩意儿就没带怕的”；</p><p>还有的人是“俺得用开水，不是开水可不瞻”。</p><p>但是很少有人想过”为什么我是死猪，为什么要用开水烫我“。</p></blockquote><h2 id="一、观感"><a href="#一、观感" class="headerlink" title="一、观感"></a>一、观感</h2><p>天津真的很像十年前的石家庄。我指的不是发展程度，而是市容市貌。在街上随处可见将背心挽到胸口的大爷，拿着火钳子捅咕炉子，炭火上是一两只烤鸡翅或者烤虾。旁边的饭店有踩着趿拉板儿的姐姐拎着水管往街上滋着黑水。一个个脸上都是泥渍和晒疮的小孩子，将砖头揉碎了倒到书包里，两三个人拥着一辆比人都高的华丽的变速自行车，向着挤满三轮的岔路口奔去。而石家庄，可能是因为我不常回家的缘故，早已昏沉沉地睡去。</p><p>这是西北角的景象，而在五大道，我见过了最新奇的建筑群，洋房子里长出了商户，丝毫没有嫁接或者“捏到一起”的感觉。秃头或者蓬蓬头的胖大妈从一个漂亮的西式木头窗后探出头，这如果不是发生在天津，又能发生在哪里？</p><p>来到天津以后，我才感觉到，似乎我的一部分是在天津的。这个地方没有小红书上说得那么俏皮或者幽默，而更像是我小时候读到的《神鞭》一样，这里的人为了某种传统的生活方式，而憋着一口气，他们迫不及待地向别人证明，更向自己证明，我们这么活没有错。</p><p>在华北平原上，人们惧怕没有“活儿”，因为没活儿才意味着真正的死去。</p><hr><h2 id="二、地理"><a href="#二、地理" class="headerlink" title="二、地理"></a>二、地理</h2><p>天津地理变化似乎有些剧烈，很多地区都在反复地划入河北，或者从河北划出（甚至建国后天津还成为过河北省的省会，甚至反复省会和直辖反复横跳）。关于天津建国后地理范围的具体变化，可以参考<a href="https://www.douyin.com/zhuanti/7283922349697697850">这里</a>。</p><p><img src="/posts/cb9fcc81/image-20240702110021985.png" alt="image-20240702110021985"></p><p>从历史角度分析，其实天津可以被分为两个“源”，一个是沿海的塘沽，另一个是不沿海，而是在海河三岔口附近的天津城。也就是上图东侧的部分和西侧的部分。这两个部分其实是承担了不同的城市职责。塘沽非常好理解，他临近渤海湾，是天然的海运港口。不好理解的是天津城，因为它不沿海，为什么要在内陆发展出这样的一个城市。</p><p><img src="/posts/cb9fcc81/v2-52a77dce617dbf748a04beba72673f2a_720w.webp" alt="img"></p><p>这有两个原因：自然原因和经济原因。自然原因是黄河改道与渤海海侵。现在的黄河是从山东入海，但是黄河泛滥的时候，会导致决堤更改河道，有的时候是会从天津入海的。黄河从天津入海携带的大量泥沙让天津形成了沿海的冲积平原，也就是塘沽地区，但是这片地区过于低洼，土质松软，很容易被渤海淹没，所以不适合建立大城市。而稍微靠近内陆的天津城。则没有这种担忧。</p><p><img src="/posts/cb9fcc81/703.png" alt="img"></p><p>经济原因是除了海运，天津城还承担了河运的职责。天津城位于海河、滹沱河和潞河的三岔口处，同时还有京杭大运河的的永济渠也在此处交汇，在这个位置围绕直沽修建天津城就很合理了。</p><p>到了近代，天津的行政规划不断扩大，原本的塘沽变成了滨海新区，而天津城逐渐成了一个卷心菜中菜心的部分，别周围的郊县包围，形成了“市内六区，四郊五县”的格局，其中：</p><ul><li>市内六区： 河北，南开，河东，红桥，河西，和平</li><li>四郊： 津南，北辰，东里，西青</li><li>五县： 蓟县，武清，宝坻，宁和，静海</li></ul><p>最后放一张现在天津的行政规划：</p><p><img src="/posts/cb9fcc81/18963.jpg" alt="天津市地图简图"></p><p>或者这张更形象一些：</p><p><img src="/posts/cb9fcc81/v2-b7476ae920318e6cae7159f9f314cf59_720w.webp" alt=""></p><p>而从旅游角度来说，天津的景点集中于市内六区（如果不去海边玩的话），其实是很小的一片地方，我在知乎找到这样一个评论形容市内六区，大概可以概括一下天津的风土人情：</p><blockquote><p>因为每个区人的来源不同，河东区是本土漕运人，南开区是城里人，红桥区是回族人，和平区是外地人，河西是庄家人，河北是铁路人。然后各个区领地意识很强，你也听说过天津媳妇不外嫁，跨区算外嫁吧。</p><p>市内六区打的不可开交，在他们眼里，郊区不配拥有姓名。“出了和平都是郊区”，别说四郊五县了，就连市内其他五区都看不上。</p><p>市里居民对于四郊五县人排斥 ，本质上是城市文明市民文化对于传统农业文明的一种排斥。</p><p>市里的和四郊五县本来就不是一个祖宗，市里的是江淮浙闽晋这五省移民后裔，主要从事工商业，是比较完整的市民社会模式。而四郊五县则是冀鲁民系后裔，主要从事农业，是传统的农业社会模式。</p><p>市区因为骨子里面是移民后代，家庭结构更加原子化，日常生活中更加遵守规则，而四郊五县是冀鲁农民后代，家庭关系更加紧密，更喜欢走人际关系。市区刀子嘴但是内心很包容，四郊五县看似嘴不如市区厉害，但是骨子里面更加排外。</p><p>像武清宝坻宁河汉沽蓟县四县一区是上世纪六七十年代划给天津的，这些地方之前一直是跟着北京或者唐山混的，对于天津没有什么认同感，反而对天津认同度高的沧州划给了河北省，德州归了山东省。</p></blockquote><p>这次旅行因为被学校 push 得太紧了，所以并没有好好逛天津的旅游景点，只是将想吃的天津美食吃了吃，所以下文只有关于美食的介绍，没有太多关于景点的介绍。</p><hr><h2 id="三、美食"><a href="#三、美食" class="headerlink" title="三、美食"></a>三、美食</h2><h3 id="3-1-昱德来"><a href="#3-1-昱德来" class="headerlink" title="3.1 昱德来"></a>3.1 昱德来</h3><p>昱德来并不是小红书或者知乎等攻略里推荐的天津传统菜馆，那些传统菜馆都在市内的东北侧，而我住在了鼓楼（也就是市中心），所以就找了宾馆附近的昱德来，发现味道还不错。这可能是因为天津菜非常传统，并没有很多的外地特色，不同的菜馆之间不会有明显差异导致的。</p><p>我最爱吃的是鸭卷，这可以说是我吃过最好吃的鸭子的烹饪方式。鸭子肉被撕成细丝，在保留肥美汁水的同时又避免了鸭肉柴硬的口感。鸭肉被鸡蛋皮和豆皮裹着下锅炸，要比北京烤鸭用荷叶饼或者面皮的方式融合得更好，更能保留鸭香。</p><p><img src="/posts/cb9fcc81/IMG20240616114751.jpg" alt=""></p><p>鲜虾茄盒是酸甜口的，做得中规中矩，并没有非常惊艳我。其实我一开始真的最想吃的就是这个，因为它有非常闪亮光泽的芡，看着就很下饭。实际吃上去吧，有点糊嗓子。</p><p><img src="/posts/cb9fcc81/IMG20240616114337.jpg" alt=""></p><p>我还吃了老爆三（也就是传统爆三样），确实处理得不错，没有什么脏器味儿或者腥膻味儿，但是依然不好吃。</p><h3 id="3-2-利德顺小老饭店"><a href="#3-2-利德顺小老饭店" class="headerlink" title="3.2 利德顺小老饭店"></a>3.2 利德顺小老饭店</h3><p>这家是我在西北角逛街时遇到的，是传统回民馆子，人非常火爆。我听旁边一个食客大哥说是天津非常好吃的一家传统菜馆，但是因为从不上美团或者大众点评，所以曝光率不是很高。</p><p>我个人感觉确实我吃到的菜品堪称惊艳！无论是从好吃的角度，还是从特色的角度来看。但是服务员真的好凶啊，我进了饭店也不领我去饭桌（人是真的多），好不容易坐下来也没人点菜，我去找前台就说让我等着。点菜的时候来了一个说着很重天津话的牛眼睛大爷，看我点了一个面筋，然后扯着嗓子嘟嘟囔囔（真的是这样，又大声又小声的）说太多油了，我吃不惯。把我吓得差点都直接不吃了。</p><p>虾仁独面筋真的超级好吃，面筋被完全浸泡在一个超绝的油里，那个油最少有白花椒油，菜籽油和椒麻油三种口感。面筋浸入在里面，又香又有嚼劲，而且油似乎有隔热的作用，当你将面筋吃进去的时候。面筋里被油阻隔的温度会在口腔里炸开，类似于在口腔里进行油泼面的淋油操作，那种蛋白质瞬间变性的口感，真的是绝了！这道菜就是我心中天津最好吃的菜！</p><p><img src="/posts/cb9fcc81/IMG20240616192134.jpg" alt=""></p><p>我去的时候就只有自己一个人，怕吃不完就点了这一份菜，但是白嘴吃似乎有些寡淡，就要了一个主食，一个服务员给我推荐了回头，我一看好贵啊，独面筋 40，这个东西也 40，但是我怕那个牛眼睛大爷又来，所以就点了：</p><p><img src="/posts/cb9fcc81/IMG20240616195952.jpg" alt=""></p><p>结果等了一个小时才上，这个东西其实要我说，非常有特色，而且不难吃，它类似于牛肉馅饼或者牛肉火烧，不同的是他的面没有刷的油更少，面皮更薄，烤制的时间更长。吃起来的口感更像是饼干而非饼，甚至让我有种吃比萨的错觉。</p><h3 id="3-3-西北角"><a href="#3-3-西北角" class="headerlink" title="3.3 西北角"></a>3.3 西北角</h3><p>西北角在旅游攻略上被传成了一个网红早餐街，我还以为会跟北京的南锣鼓巷一样，都是骗外地人的“塑料美食”呢。但是实际上这里确实非常生活化，东西也不贵，有很多居民区的大爷大妈都来这里吃。我来这里吃了两天，基本上把这面墙上的东西都吃了个遍：</p><p><img src="/posts/cb9fcc81/IMG20240617094212.jpg" alt=""></p><p>我早餐都是在利民餐厅吃的，主要是大夏天的，能有个能坐下吃饭还有空调的地方实在是太爽了：</p><p><img src="/posts/cb9fcc81/IMG20240617092951.jpg" alt=""></p><p>煎饼真的是太失望了，我听了那么久的天津相声，听了那么久天津人对于外地煎饼馃子的嘲弄，但是我自己吃的时候，真的味道是一样的，甚至天津的煎饼还更难以下咽。我小时候从书上看到过枣红色的油条，结果我转了很多的摊子，发现卖的都是黄色的油条，而且还很难吃（另外说一嘴，还是永和豆浆的油条最好吃，写得时候馋死我了），就像一个简单的面棍一样。</p><p><img src="/posts/cb9fcc81/IMG20240618091812.jpg" alt=""></p><p>嘎巴才倒是挺好吃的，嘎巴菜是面片片上面淋上麻酱腐乳和某种特制的黏糊糊的汤汁，是咸口的，我觉得挺香的，而且面片的口感哏啾啾的，不像煎饼那么浮囊。</p><p><img src="/posts/cb9fcc81/IMG20240617091139-17199124363434.jpg" alt=""></p><p>面茶跟嘎巴菜的味道差不多，真的像《俗世奇人》里描述的一样，先加半碗茶汤，再加一层芝麻，然后再加半碗茶汤，再撒一层芝麻。茶汤并不是固体，而更像是芝麻糊那样的固液交融的状态。我打算先攉拢攉拢再吃，但是旁边的天津大姨教给我不要搅和，而是要拿勺子溜着碗沿儿㧟着吃。</p><p><img src="/posts/cb9fcc81/IMG20240618092023.jpg" alt=""></p><p>卷圈的腐乳味、油渣味儿和豆芽菜的水汽味儿交织在一起，形成了一种神秘的味觉体验，这种味道甚至都有些刺鼻了（腐乳有点发酸）：</p><p><img src="/posts/cb9fcc81/IMG20240617102724.jpg" alt=""></p><p>在西北角还常见熟梨膏，但是其实和梨这种水果没啥关系，我查了查，据说是“熟哩”的音译。其做法上很类似陕西的镜糕，但是要更加难吃一些，酱料𫫇甜𫫇甜的，而糯米过于粉了，这可能是由于它并不是在一个像蒸锅一样的密闭容器，而是在一个小碗里制作的。</p><h3 id="3-4-起士林"><a href="#3-4-起士林" class="headerlink" title="3.4 起士林"></a>3.4 起士林</h3><p>非常有名的西餐馆，我觉得更难得是价格还算合理，而且服务员态度很好（感觉五大道这边市井气少一些，更加工业城市了一些）。可惜的是，这里的大列巴是要钱的（《师父》骗人！）：</p><p><img src="/posts/cb9fcc81/IMG20240618103345.jpg" alt=""></p><p>店内的装潢有一种中西混合的感觉，西式的主体和中式的繁复装饰：</p><p><img src="/posts/cb9fcc81/IMG20240618105955.jpg" alt=""></p><p>我在想耿良辰是不是原本比武赢了后就是要在这张楼梯口的大桌子上吃饭：</p><p><img src="/posts/cb9fcc81/IMG20240618110000.jpg" alt=""></p><p>这个吧台也很漂亮：</p><p><img src="/posts/cb9fcc81/IMG20240618110822.jpg" alt=""></p><p>坐下来窗外是一个外国风情的音乐厅：</p><p><img src="/posts/cb9fcc81/IMG20240618111449.jpg" alt=""></p><p>我看门口介绍说是德国餐厅，居然意外的好吃（什么刻板印象，我该死），红汤有很浓郁的酵香，而且还不酸𫫇：</p><p><img src="/posts/cb9fcc81/IMG20240618110549.jpg" alt=""></p><p>奶油芝士杂拌芝士量很足，拉丝很明显，各种肉类都很好吃：</p><p><img src="/posts/cb9fcc81/IMG20240618111729.jpg" alt=""></p><p>我平时并不喝酒，不知道是不是心理因素，我觉得这杯金汤力非常清冽，没有酸锈味儿：</p><p><img src="/posts/cb9fcc81/IMG20240618112918-17199229470811.jpg" style="zoom:25%;"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于“死猪不怕开水烫”这句话，似乎每个人的理解是不同的：&lt;/p&gt;
&lt;p&gt;有的人是“小太爷告诉你，咱得是猪，可不是那鸡鸭的便宜玩意儿”；&lt;/p&gt;
&lt;p&gt;有的人是“跟嫩么说，别听前面的猪渍歪，介玩意儿就没带怕的”；&lt;/p&gt;
&lt;p&gt;还有的人是“俺得用开水，不是开水可不瞻”。&lt;/p&gt;
&lt;p&gt;但是很少有人想过”为什么我是死猪，为什么要用开水烫我“。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、观感&quot;&gt;&lt;a href=&quot;#一、观感&quot; class=&quot;headerlink&quot; title=&quot;一、观感&quot;&gt;&lt;/a&gt;一、观感&lt;/h2&gt;&lt;p&gt;天津真的很像十年前的石家庄。我指的不是发展程度，而是市容市貌。在街上随处可见将背心挽到胸口的大爷，拿着火钳子捅咕炉子，炭火上是一两只烤鸡翅或者烤虾。旁边的饭店有踩着趿拉板儿的姐姐拎着水管往街上滋着黑水。一个个脸上都是泥渍和晒疮的小孩子，将砖头揉碎了倒到书包里，两三个人拥着一辆比人都高的华丽的变速自行车，向着挤满三轮的岔路口奔去。而石家庄，可能是因为我不常回家的缘故，早已昏沉沉地睡去。&lt;/p&gt;
&lt;p&gt;这是西北角的景象，而在五大道，我见过了最新奇的建筑群，洋房子里长出了商户，丝毫没有嫁接或者“捏到一起”的感觉。秃头或者蓬蓬头的胖大妈从一个漂亮的西式木头窗后探出头，这如果不是发生在天津，又能发生在哪里？&lt;/p&gt;
&lt;p&gt;来到天津以后，我才感觉到，似乎我的一部分是在天津的。这个地方没有小红书上说得那么俏皮或者幽默，而更像是我小时候读到的《神鞭》一样，这里的人为了某种传统的生活方式，而憋着一口气，他们迫不及待地向别人证明，更向自己证明，我们这么活没有错。&lt;/p&gt;</summary>
    
    
    
    <category term="吃喝玩乐" scheme="https://thysrael.github.io/categories/%E5%90%83%E5%96%9D%E7%8E%A9%E4%B9%90/"/>
    
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="吃喝玩乐" scheme="https://thysrael.github.io/tags/%E5%90%83%E5%96%9D%E7%8E%A9%E4%B9%90/"/>
    
    <category term="流浪天津" scheme="https://thysrael.github.io/tags/%E6%B5%81%E6%B5%AA%E5%A4%A9%E6%B4%A5/"/>
    
  </entry>
  
  <entry>
    <title>自由王国-字体</title>
    <link href="https://thysrael.github.io/posts/6a65902d/"/>
    <id>https://thysrael.github.io/posts/6a65902d/</id>
    <published>2024-06-10T08:08:50.000Z</published>
    <updated>2024-10-17T06:35:03.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编码"><a href="#一、编码" class="headerlink" title="一、编码"></a>一、编码</h2><p>此章的目的是弄清楚 ASCII, GBK, Unicode, UTF-8 编码的区别，大部分知识都来源于<a href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">这里</a>。所以我只是简单转述一下：</p><p>ASCII 是最为古老的编码方式，它指的是用一个字节也就是 8 bit 完成编码，实际上只用了 7 bit ，最高位的值衡为 0 （这也成了其他编码方式兼容 ASCII 的一个重要抓手）。也就是说，ASCII 只能编码 2<sup>7</sup> = 128 个文字，这对英文这种只有 26 个字母的语言体系是足够的。</p><p>但是 ASCII 并不能满足很多类似英语的语言体系，比如说 <code>é, ג</code> 这种字符都是原有的 ASCII 所没有的，但是幸运的是，很多语言的字符数本来就不多，比如俄语是 33 个，而法语是基础的 26 个英文字母加音标。所以这些语言同样可以用一个字节进行编码，英语字符占据了 <code>0 ~ 127</code> ，它们就占据了 <code>128 ~ 255</code> 。这样的缺点就是不同国家的 <code>128 ~ 255</code> 表示不同的字母，彼此之间并不兼容。</p><p>但是像汉语这样的语言就没有那么轻松了，他们就算占据了 <code>128 ~ 255</code> 位，也最多增加 128 个字符，这对于有 10 万个字符的汉语来说是杯水车薪。所以中国就开发了 GB2312 编码系统，后来演变成了 GBK 系统。总的来说，就是采用两个 <code>128 ~ 255</code> 的字节来表示一个汉字（应该是差不多），这样的话大约可以表示 2 万多个汉字，但是这样其实有一些生僻一些的字也是无法表示的。</p><p>这些各个国家私自拓展 ASCII 编码的行为导致了各种语言的编码系统都不兼容，随着互联网的兴起，一套兼容的编码系统呼之欲出，也就是 Unicode ，它用 32bit 表示一个符号，那么就可以表示 2 亿多个符号，这足够容纳人类的所有语言，可以在<a href="https://symbl.cc/en/unicode-table/">这里</a>查询。Unicode 编码通常有一个 <code>U+</code> 的前缀。但是随着而来的问题是，原本需要用 8bit 表示的英文字母，现在需要用 32bit 了，这显然不是一个好事情。</p><p>为了权衡数据大小和兼容性，以 Unicode 为编码基础，人们提出了 UTF-8, UTF-16, UTF-32 等具体的编码方案。以 UTF-8 为例，它使用变长编码，压缩了原本 32bit 的字符。在 UTF-8 中，字符可能长度是 8, 16, 32bit ，这样兼顾了大小和兼容性。UTF-16 和 UTF-32 则都是定长编码，UTF-16 适用于需要处理大量双字节字符（如亚洲文字）的场景。UTF-32 则适用于需要处理所有 Unicode 字符，且对内存空间要求较高的情况。</p><p>UTF-8 看似兼顾了优势，但是不定长的特性使得解码效率降低，而且这使得像 C++ 这样的语言，字符数组的概念变得容易混淆，当我说 <code>s[3]</code> 时，很难确定它是一个特定的字符，还只是字符的某一部分。</p><hr><h2 id="二、渲染"><a href="#二、渲染" class="headerlink" title="二、渲染"></a>二、渲染</h2><h3 id="2-1-点阵字体"><a href="#2-1-点阵字体" class="headerlink" title="2.1 点阵字体"></a>2.1 点阵字体</h3><p>在最开始的时候，字体是用点阵（bitmap）的方式描述的，也就是这个字体记录了不同大小（字号）的字符的像素的排列方式，非常的朴素和直观。但是这种方式是的缺点在于，不同字号的字都分别需要记录一次像素的排列方式，所以如果恰好这个字号没有记录，就非常尴尬了（不可能每个字号都有），只能用用相邻的有记录的字号进行推算。而且这种方式的也不适合进行一些数学相关的处理（比如加粗、倾斜、缩放和旋转）。</p><h3 id="2-2-矢量字体"><a href="#2-2-矢量字体" class="headerlink" title="2.2 矢量字体"></a>2.2 矢量字体</h3><p>为了解决这个问题，人们提出了矢量字体，这种字体不再记录具体的像素排列方式，而是用数学上的贝塞尔曲线在一个虚拟的网格（类似于坐标系，但是并不连续）描述字体。这种方式解决了点阵字体的缺点，如下所示：</p><p><img src="/posts/6a65902d/clipboard-20240610T153703.png" alt=""></p><p>最开始的时候，是 Adobe 公司最先开发了 Type1 矢量字体格式（后缀名为 <code>pfb</code>），但是 Adobe 太贵了，所以 MS 和 Apple 联手开发新的矢量字体，但是只有 Apple 开发成功了，它的作品是 TrueType（后缀名为 <code>ttf</code>，也就是 true type format）。后来 MS 又和 Adobe 公司开发出了 OpenType（后缀名为 <code>otf</code>，也就是 open type format），这种字体也被称为 Type2。除此之外，还有为 web 而生的字体标准 <code>woff</code> 和 <code>woff2</code>，它们的优势在于压缩率高。我们还常见一种后缀名为 <code>ttc</code> 的文件，它的全称是 TrueType Collection，是在一单独文件结构中包含多种字体，以便更有效地共享轮廓数据，当多种字体共享同一笔画时，TTC 技术可有效地减小字体文件的大小。</p><p>总的来说，Type1 字体基本上已经不常见了，而 OTF 因为吸取了 TTF 的经验，所以更为先进，但是 TTF 具有先发优势，兼容性更好。不过两者的差别并不明显。</p><h3 id="2-3-屏幕"><a href="#2-3-屏幕" class="headerlink" title="2.3 屏幕"></a>2.3 屏幕</h3><p>这里插叙一段关于屏幕的介绍。我个人的理解，屏幕是一块布满像素点的网格板子，其核心在于<strong>分辨率</strong>，也就是屏幕的实际大小和其上的像素点的关系。我们在字体设置时常常有诸多单位，记录如下：</p><ul><li>pt：译作“磅”，这是一个物理单位，是 1/72 英寸的。直观来看，我个人常用 14pt 左右的字体写代码，这样的我 15 寸的电脑大约能容纳 40 行。这个字体对于写代码来说差不多，但是对于纸质阅读来说，是有一些大的。之所以我们需要用磅，是因为人眼睛直观感受到的是物理尺寸，无论屏幕的像素是多少，一个过小 pt 的字，总是不容易识别的。</li><li>px：译作“像素”，这是一个显示单位，也就是 1px 就指的是一个像素的宽度。当字体物理高度（也就是 pt 固定）固定的时候，像素越多，字体的边缘就会越圆润细腻。</li><li>ppi：pixel per inch，可以被视为“分辨率”，还有一个类似的单位叫作 dpi，dpi 用于衡量打印物上每英寸的点数密度，而 ppi 用于屏幕，含义上没有过大区别。其实严格上说，ppi 是决定屏幕是否细腻的核心。</li><li>em：这个就游离于上述三个概念之外了，它指的是一个字母 <code>e</code> 的宽度。</li></ul><p>我们有如下公式：</p><script type="math/tex; mode=display">1 px = \frac{72}{ppi} pt</script><p>考虑到 pt 是物理实际长度不可变，ppi 是屏幕特性不可变，所以基本上这个公式除了计算像素宽度外，似乎并没有作用。而实际上并不是这样的，因为屏幕上的软件其实是并不知道物理长度的，它们总不能从屏幕里伸出一只手来拿个尺子量一量字体高度是不是真的是 14pt。它们是根据 ppi 来计算字体高度的。也就是说 ppi 作为一个参数传入给了程序。</p><p>这种方式就衍生了一种新的调节字体高度的方式，除了传统的修改字体字号，现在还可以修改 ppi，将 ppi 改大，就会导致字体高度也变大。但是需要强调的是，此时的 ppi 已经不再是屏幕的一个物理参数了，而变成了一个程序渲染的参数，可以脱离实际意义。</p><p>那么为什么在可以直接调节字号的情况下，还修改 ppi 呢？这是因为屏幕上不只有文字，还有许多其他的 UI 组件，修改 PPI 可以统一将他们一起放大缩小。至于为啥要修改它们，这可能是因为人眼具有“近大远小”的机制，所以离人较远的显示器，是需要通过放大来保证落入眼睛里时是正常大小的。</p><h3 id="2-3-光栅化"><a href="#2-3-光栅化" class="headerlink" title="2.3 光栅化"></a>2.3 光栅化</h3><p>当然矢量字体也并非完全碾压点阵字体，点阵字体展示在屏幕上是非常直观的，基本上像素是怎么被记录的，就怎么显示到屏幕上就可以了（这个过程称之为渲染）。但是矢量字体想要映射到一个屏幕像素网格上，那么就会发生一个“从连续到离散”的过程了，这种渲染过程被称为光栅化，如图所示：</p><p><img src="/posts/6a65902d/fig3-2-1.png" alt="figure_3"></p><p>从上图就可以看出，光栅化如果不加优化，直接映射，是非常丑陋的。而点阵字体因为开发时面对的就是网格，反而设计师不会设计出粗糙丑陋的字体。那么光栅化具体有哪些优化呢？</p><p>为了解决渲染后的字体有一种机器渲染的粗糙和死板感的问题，比如说下面的 e 这个字符，顶部只有一个像素：</p><p><img src="/posts/6a65902d/IF3.png" alt="figure_4"></p><p>人们发明了<strong>字型微调（hinting）</strong>，它指的是通过稍微调整字形（一般是倾斜）的方式，来达到一种更加“拟人”的渲染方式，当然如果过度使用这种方法，也会导致字形发生严重的扭曲。</p><p><img src="/posts/6a65902d/IF4.png" alt="figure_5"></p><p><strong>抗锯齿（anti-aliasing）</strong>则是另一种优化手段，他指的是当像素过少的时候，很容易出现像素点之间的方块块，就会形成鳞次栉比的“锯齿”，这个时候就很丑陋，那么我们可以将边缘的像素点改成灰色（原本是黑色或者白色），然后就可以模糊了原本的锯齿。这种方法也称为<strong>灰度渲染（Grayscale rendering）</strong>。经过抗锯齿化的字体的缺点是边缘可能有些“模糊”。</p><p>还有一种类似的方法叫作<strong>亚像素渲染（Subpixel rendering）</strong>，它利用了现行的 RGB 显示屏的像素点其实是 3 个分别显示红绿蓝颜色的“亚像素”拼成的，所以可以只显示三分之一个像素或者三分之二个像素，这样分辨率相当于在横向上提高了 3 倍。但是除了边缘模糊的缺点外，这种方法还会造成某种“腻感”，这是因为边缘出现了颜色。</p><p>抗锯齿和亚像素渲染的概念如下图所示：</p><p><img src="/posts/6a65902d/aaaa.png" alt="figure_6"></p><hr><h2 id="三、字族"><a href="#三、字族" class="headerlink" title="三、字族"></a>三、字族</h2><h3 id="3-1-风格"><a href="#3-1-风格" class="headerlink" title="3.1 风格"></a>3.1 风格</h3><p>评价一个字体的风格，最为简单的有 3 个标准：</p><ol><li>有衬线还是无衬线：Serif or Sans-serif</li><li>等宽还是变宽：Monospace or Proportional</li><li>印刷体还是手写体：Gothic or Script</li></ol><p>在英文中的区别我就不细说了，主要讲这些概念的“中国化”。无衬线的字体一般用于标题等醒目的地方，所以对应汉字的“黑体”，而有衬线的字体更适合阅读，对应汉字的“宋体”。汉字是方块字，所以一般都是等宽的，这里说汉字等宽，往往是指汉字需要和两个英文字母等宽。上面说的黑体和宋体都很正式，是印刷体，而“仿宋”或者“楷体”则更加灵活，对应手写体。</p><h3 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h3><p>字体有很多属性，常用的有字族（family）、倾斜（slant）、字重（weight）。后两者合一起叫样式（style）。</p><p>字族就是字体的名字。</p><p>倾斜就是斜不斜，英文叫 Roman，Italic 或者 Oblique ，Italic 是专门的斜体写法（更接近手写样式）， Oblique 是把常规写法倾斜一下完事。</p><p>字重就更简单了，就是笔划的粗细。常见的有 Regular、Normal、Medium、Bold、Semibold、Black、Thin、Light、Extralight 等。</p><h3 id="3-3-汉字"><a href="#3-3-汉字" class="headerlink" title="3.3 汉字"></a>3.3 汉字</h3><p>Noto 系列字体是 Google 主导的，名字的含义是<strong>没有豆腐（no tofu）</strong>，因为缺字时显示的方框或者方框被叫作 tofu 。思源系列字体是 Adobe 主导的。其中汉字部分被称为思源黑体和思源宋体，是由这两家公司共同开发的，两个字体系列的汉字部分是一样的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、编码&quot;&gt;&lt;a href=&quot;#一、编码&quot; class=&quot;headerlink&quot; title=&quot;一、编码&quot;&gt;&lt;/a&gt;一、编码&lt;/h2&gt;&lt;p&gt;此章的目的是弄清楚 ASCII, GBK, Unicode, UTF-8 编码的区别，大部分知识都来源于&lt;a href=&quot;https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;这里&lt;/a&gt;。所以我只是简单转述一下：&lt;/p&gt;
&lt;p&gt;ASCII 是最为古老的编码方式，它指的是用一个字节也就是 8 bit 完成编码，实际上只用了 7 bit ，最高位的值衡为 0 （这也成了其他编码方式兼容 ASCII 的一个重要抓手）。也就是说，ASCII 只能编码 2&lt;sup&gt;7&lt;/sup&gt; = 128 个文字，这对英文这种只有 26 个字母的语言体系是足够的。&lt;/p&gt;
&lt;p&gt;但是 ASCII 并不能满足很多类似英语的语言体系，比如说 &lt;code&gt;é, ג&lt;/code&gt; 这种字符都是原有的 ASCII 所没有的，但是幸运的是，很多语言的字符数本来就不多，比如俄语是 33 个，而法语是基础的 26 个英文字母加音标。所以这些语言同样可以用一个字节进行编码，英语字符占据了 &lt;code&gt;0 ~ 127&lt;/code&gt; ，它们就占据了 &lt;code&gt;128 ~ 255&lt;/code&gt; 。这样的缺点就是不同国家的 &lt;code&gt;128 ~ 255&lt;/code&gt; 表示不同的字母，彼此之间并不兼容。&lt;/p&gt;
&lt;p&gt;但是像汉语这样的语言就没有那么轻松了，他们就算占据了 &lt;code&gt;128 ~ 255&lt;/code&gt; 位，也最多增加 128 个字符，这对于有 10 万个字符的汉语来说是杯水车薪。所以中国就开发了 GB2312 编码系统，后来演变成了 GBK 系统。总的来说，就是采用两个 &lt;code&gt;128 ~ 255&lt;/code&gt; 的字节来表示一个汉字（应该是差不多），这样的话大约可以表示 2 万多个汉字，但是这样其实有一些生僻一些的字也是无法表示的。&lt;/p&gt;</summary>
    
    
    
    <category term="自由王国" scheme="https://thysrael.github.io/categories/%E8%87%AA%E7%94%B1%E7%8E%8B%E5%9B%BD/"/>
    
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="自由王国" scheme="https://thysrael.github.io/tags/%E8%87%AA%E7%94%B1%E7%8E%8B%E5%9B%BD/"/>
    
    <category term="字体" scheme="https://thysrael.github.io/tags/%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>海边拾贝-TCCL</title>
    <link href="https://thysrael.github.io/posts/3e82a961/"/>
    <id>https://thysrael.github.io/posts/3e82a961/</id>
    <published>2024-06-03T03:11:57.000Z</published>
    <updated>2024-10-17T06:35:03.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCCL-为-PCIe-GPU-集群发现更好的通信路径"><a href="#TCCL-为-PCIe-GPU-集群发现更好的通信路径" class="headerlink" title="TCCL: 为 PCIe GPU 集群发现更好的通信路径"></a>TCCL: 为 PCIe GPU 集群发现更好的通信路径</h1><p>论文地址：<a href="https://dl.acm.org/doi/10.1145/3620666.3651362">https://dl.acm.org/doi/10.1145/3620666.3651362</a></p><p>项目地址：<a href="https://github.com/mcrl/tccl">https://github.com/mcrl/tccl</a></p><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><h3 id="1-1-计算集群"><a href="#1-1-计算集群" class="headerlink" title="1.1 计算集群"></a>1.1 计算集群</h3><p>随着深度学习模型规模的增大，单一的 GPU 已经无法满足计算的需要了，人们使用计算集群（Computation Cluster），也就是一组相关的 CPU GPU 网卡和连接它们的数据通路组成。这样计算任务就可以被并行了，原本的计算也变成了”计算 + 传输”两个部分。</p><p>从并行方式上划分，可以分为数据并行（data parallism）和算法并行（pipeline parallism）。数据并行指的是将一个主任务分成多个相互独立的子任务。而算法并行指的是将主任务划分出不同的阶段，形成流水线，各个阶段依次依赖。数据并行通信的对带宽要求并不高；算法并行通信的主要操作是传递，对带宽较为敏感。似乎这种分类并没有统一标准，有许多类似的概念。</p><h3 id="1-2-集体通信"><a href="#1-2-集体通信" class="headerlink" title="1.2 集体通信"></a>1.2 集体通信</h3><p>集体通信（Collective Communication）是计算集群实现分布式并行计算的一个重要过程。代表操作有 <code>reduce, scatter, gather</code> 等。</p><p>其中成环算法（Ring algorithm）在集体通信的实现中非常重要：成环算法将 GPU 组成一个环，方便进行数据的分发和采集。如图所示：</p><p><img src="/posts/3e82a961/2024-06-02_14-20.png" alt=""></p><p>成环算法在深度学习中有着广泛的应用，比如说数据并行（data parallelism），张量并行（tensor parallelism），序列并行（sequence parallelism），专家并行（Expert parallelism）中有着广泛应用。</p><p>我个人感觉集体通信更服务于数据并行或者类似概念的并行，因为这些操作对数据并行的”将主任务环分为多个子任务，将子任务合并成主任务”的逻辑很像，而与算法并行所需要的传递通信关系并不大。</p><h3 id="1-3-分类"><a href="#1-3-分类" class="headerlink" title="1.3 分类"></a>1.3 分类</h3><p>本文将目前的计算集群分成了两类，高带宽系统（high-bandwidth systems）和依赖 PCIe 的系统（PCIe-dependent systems）。</p><p>高带宽系统如 NVIDIA DGX-1 是硬件厂商打造的”旗舰系统”，具有专有的高带宽通路，比如 NVLink ，高带宽的专用交换机，比如说 NVSwitch 和 PCIe Switch ，高效的通信机制，可以全功率无阻塞的传递数据。</p><p>而许多研究院、初创公司和云服务厂商并没有足够的资金去购买这种高带宽集群，他们使用的是依赖 PCIe 的系统。这种系统没有高速数据通路，只能将 CPU 的 PCIe host bridge 和 NUMA 架构下的 CPU socket 当作交换通道，常常因为 GPU 间不支持直接传输功能，而需要借助 CPU 内存间接传输。这些特征说明了依赖 PCIe 的系统的本质是低带宽系统，为了方便行文，后续都称之为低带宽系统。</p><p>两种系统的示意图如下：</p><p><img src="/posts/3e82a961/2024-06-02_15-05.png" alt=""></p><p>根据阿里巴巴的调查报告，大约 90.4% 的系统是低带宽系统。遗憾的是，现有的集体通信库在低带宽系统上表现远没有理论预估得好，出现了数据通路堵塞的现象，而在高带宽系统上则不存在这个问题。这是因为这些函数库都是针对高带宽系统设计的，忽略了低带宽系统的特殊性。</p><h3 id="1-4-集群内部架构"><a href="#1-4-集群内部架构" class="headerlink" title="1.4 集群内部架构"></a>1.4 集群内部架构</h3><h4 id="1-4-1-集群设备"><a href="#1-4-1-集群设备" class="headerlink" title="1.4.1 集群设备"></a>1.4.1 集群设备</h4><p>在计算集群中，除了 CPU 和 GPU 这样的计算设备外，还有内存等设备也为计算任务的完成贡献了力量。</p><div class="table-container"><table><thead><tr><th>设备</th><th>解释</th></tr></thead><tbody><tr><td>CPU</td><td>初始化数据传输、参与数据搬运，CPU 用 Bounce Buffer 表示</td></tr><tr><td>GPU</td><td>进行计算任务</td></tr><tr><td>NVSwitch</td><td>英伟达专用的交换机</td></tr><tr><td>PCIe Switch</td><td>PCIe 设备交换机</td></tr><tr><td>IB NIC</td><td>网卡，用于跨芯片通信</td></tr><tr><td>Bounce Buffer</td><td>CPU 内存中的临时缓冲区，用于在数据传输过程中存储中转数据</td></tr></tbody></table></div><h4 id="1-4-2-数据通路"><a href="#1-4-2-数据通路" class="headerlink" title="1.4.2 数据通路"></a>1.4.2 数据通路</h4><p>数据通路是连接集群设备的线路，他们有带宽的差别，种类如下（表中数据没有经过详细考证）：</p><div class="table-container"><table><thead><tr><th>通路</th><th>带宽（GB/s）</th><th>解释</th></tr></thead><tbody><tr><td>NVLink</td><td>300 ~ 1800</td><td>英伟达专用的通路</td></tr><tr><td>PCIe</td><td>30 ~ 120</td><td>PCIe 设备使用的通路</td></tr><tr><td>IB</td><td>2 ~ 30</td><td>IB NIC 使用的通路</td></tr><tr><td>QPI</td><td>8 ~ 20</td><td>NUMA 节点中 CPU 间的通路</td></tr></tbody></table></div><h4 id="1-4-3-NUMA"><a href="#1-4-3-NUMA" class="headerlink" title="1.4.3 NUMA"></a>1.4.3 NUMA</h4><p>NUMA（Non-Uniform Memory Access）架构在计算集群中指的是集群中的设备（CPU，内存，网卡，GPU）被组成成了多个节点（Node）。当 GPU、网卡和 CPU 主内存属于同一 NUMA 节点时，它们之间的通信速度会更快。相反，如果它们属于不同的 NUMA 节点，则可能会产生较高的访问延迟和较低的带宽。</p><p>抽象来看，一个计算集群可以被理解为一个具有多个子图的图，每个子图是一个 NUMA Node 。计算设备是图上的点，而数据通路是图上的边。</p><p>成环问题就是在这个图上找到一个带宽最大的环的问题。</p><hr><h2 id="二、设计"><a href="#二、设计" class="headerlink" title="二、设计"></a>二、设计</h2><h3 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a>2.1 Overview</h3><p>TCCL 基于 NCCL 库（这是英伟达开发的一款集体通信库）构建。分为 Profiler 和 PathFinder, Profiler 用于测试带宽，PathFinder 用于成环路径生成，结构如图所示：</p><p><img src="/posts/3e82a961/overview.png" alt=""></p><p>在初始化阶段，Profiler 会测试实际带宽，PathFinder 会根据测试结果生成节点内环和节点内链，在调用阶段，PathFinder 会根据 Communicator 的要求返回节点内环，如果发生跨节点通信，PathFinder 会将节点内链组合起来形成跨节点环。</p><h3 id="2-2-Profile"><a href="#2-2-Profile" class="headerlink" title="2.2 Profile"></a>2.2 Profile</h3><p>为了测试精准性，原有的 benchmark 需要运行多次，而每次的初始化时间不固定，所以最后测试出来的 transfer 开销也是不固定的，而且每次测试前都需要进行初始化，非常耗时。TCCL 改进了原有的测试实际带宽的形式，提供了一个进程池用于测量，只需要 spawn 和 init 一次即可，并且在测试前还需要进行同步，提高测试精读，如下所示：</p><p><img src="/posts/3e82a961/profile.png" alt=""></p><h3 id="2-3-PathFinder"><a href="#2-3-PathFinder" class="headerlink" title="2.3 PathFinder"></a>2.3 PathFinder</h3><p>路径可以分为节点内路径和跨节点路径。因为可能的路径太多了，所以没有办法枚举来获得最优解。所以 TCCL 先用一个类似 Dijkstra 的优先队列最短路径算法来求取节点内的最优路径，然后再用动态规划结合上一问的解来求解跨节点的最优路径。</p><p>求解节点内最优路径的伪代码如下：</p><p><img src="/posts/3e82a961/2024-06-01_10-46-28_screenshot.png" alt=""></p><p>这个算法从两个数据结构开始：一个是需要访问的 GPU 集合 <code>G</code> （相当于点集），另一个是一个最大优先队列 <code>Q</code>，其中带宽是 key，transfer set 是 value （相当于边集）。这个队列里会包括所有已经 profiled 过了（也就是知道带宽了）但是还可以进一步加入（append） transfer 的所有 transfer set 。这和 dijkstra 算法很像，这是因为 dijkstra 算法可以用优先队列来选择出下一步要 append 的边（也就是最短的边），而这里用最大优先队列来选择最大带宽的边。带宽和边长有一定的相似性。</p><p>和 dijkstra 原理类似，当 <code>T</code> 成环的时候，它一定是优先队列中带宽最大的，同时那些没有加入队列的路径，肯定不如 <code>T</code> 的带宽大。</p><p>而节点间的求解，因为节点过多，所以用 dijkstra 算法复杂度（ $O((V+E)logV)$ ）会提高，先找到节点内的短链（使用 dijkstra 算法），再将这些短链在节点间连成环。</p><hr><h2 id="三、实验"><a href="#三、实验" class="headerlink" title="三、实验"></a>三、实验</h2><h3 id="3-1-环境设置"><a href="#3-1-环境设置" class="headerlink" title="3.1 环境设置"></a>3.1 环境设置</h3><p>实验采用了 3 种低带宽的计算集群，分别是 AMD-V100, AMD-3090, Intel-V100 ，其具体配置如下：</p><p><img src="/posts/3e82a961/clusters.png" alt=""></p><p>实验与 NCCL 和 MSCCL 进行对比。NCCL 在初始化阶段就确定了路径，所以不需要运行时 profile 。MSCCL（Multiple Schedulers for Collective Communication Library）是建立在 NCCL 之上的运行时系统。它利用 TACCL 产生的通信调度，并结合任务的执行计划，实现高效的集合通信。</p><h3 id="3-2-拥塞模式"><a href="#3-2-拥塞模式" class="headerlink" title="3.2 拥塞模式"></a>3.2 拥塞模式</h3><p>TCCL 记录了当发生拥塞（也就是实际带宽与理想带宽出现严重不符）时的模式（congestion pattern），但是却没有详细分析这些拥塞的成因，也没有利用这些模式优化算法。</p><p>TCCL 记录了 3 种模式：</p><p><img src="/posts/3e82a961/30e2f3013d50eb93abae86066be46f39_4_Table_1_154416043.png" alt=""></p><p>1，2，3 号实验说明，当 GPU 一边写 CPU 内存，一边写其他 NUMA Node GPU 内存时，会出现堵塞。</p><p>从第 6 和第 9 组实验中可以看出，这里说得是如果不同 Node 间的 GPU 直接写内存，那么性能会出现不可解释地下降，所以不如改用 bounce buffer 。</p><p>从 10 和 11，12 和 13 的对比中可以看出，由于 CPU 内存带宽有限，当太多的传输集中在同一 NUMA 节点的 CPU 内存上时，性能可能会下降。所以要更换为不同的 CPU。</p><p>我个人觉得这里的意义只说说明了对于低带宽系统，会出现许多难以预料的拥塞，原本基于理论带宽构建的库并不适合低带宽系统。</p><h3 id="3-3-集体通信原语"><a href="#3-3-集体通信原语" class="headerlink" title="3.3 集体通信原语"></a>3.3 集体通信原语</h3><p>我们测试了 5 种集体通信元语在 3 种库上的对比，结果如图：</p><p><img src="/posts/3e82a961/compare1.png" alt=""></p><p>可以看到 TCCL 相较于 baseline 具有 1 ~ 2 倍的提速。这是因为 TCCL 在路径规划是避开了带宽较小（因为发生了堵塞）的通路（红色所示）。</p><p><img src="/posts/3e82a961/red.png" alt=""></p><h3 id="3-4-深度学习模型"><a href="#3-4-深度学习模型" class="headerlink" title="3.4 深度学习模型"></a>3.4 深度学习模型</h3><p>深度学习训练模型结果对比如图：</p><p><img src="/posts/3e82a961/compare2.png" alt=""></p><p>与 TCCL 在单个原语中实现的加速相比，这种加速相对较小，因为在纯数据并行化配置中，通信仅占总执行时间的约 15%。</p><p>DL 模型测试不乐观的原因是这些 DL 模型都是为高带宽集群设计的。如果希望低带宽集群和 TCCL 发挥作用，需要新的 DL 模型设计思路。</p><hr><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>TCCL 在集体通信库上针对依赖 PCIe 的系统（低带宽系统）进行了优化。相较于原有的 NCCL 之类的库，有如下优势：</p><ol><li>考虑了不存在超高带宽（如 NVLink）的数据通路情况，超高带宽容易让算法开发难度降低。</li><li>考虑了 NUMA Node 内部设备较少的情况，也就是考虑了更多跨节点通信的情况。</li><li>考虑了包含 Bounce Buffer 或者 NIC 等设备的路径，这是因为低带宽系统中的 Direct Write 较弱。</li><li>考虑了实际发生的并行传输时的拥塞现象，不再用理论带宽作为算法依据。</li></ol><p>我个人觉得 TCCL 的优化并不是仅针对于低带宽集群的特异性，有些优化是 general 的：</p><ol><li>dijkstra 算法配合动态规划降低算法复杂度。</li><li>用拓扑双射优化 Cache 提高运行效率。</li><li>维护进程池方便准确测量实际带宽</li></ol><p>这些举措放到高带宽系统上依然也有优化作用。</p><p>此外，对于拥塞导致的带宽下降，本文只是在初始化阶段简单了规避了拥塞发生的通路。而拥塞控制如果是一个运行时动态调整的操作，我觉得可能会更好，实时检测各个数据通路的拥塞情况，并据此改变路径的选择。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TCCL-为-PCIe-GPU-集群发现更好的通信路径&quot;&gt;&lt;a href=&quot;#TCCL-为-PCIe-GPU-集群发现更好的通信路径&quot; class=&quot;headerlink&quot; title=&quot;TCCL: 为 PCIe GPU 集群发现更好的通信路径&quot;&gt;&lt;/a&gt;TCCL: 为 PCIe GPU 集群发现更好的通信路径&lt;/h1&gt;&lt;p&gt;论文地址：&lt;a href=&quot;https://dl.acm.org/doi/10.1145/3620666.3651362&quot;&gt;https://dl.acm.org/doi/10.1145/3620666.3651362&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/mcrl/tccl&quot;&gt;https://github.com/mcrl/tccl&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;h3 id=&quot;1-1-计算集群&quot;&gt;&lt;a href=&quot;#1-1-计算集群&quot; class=&quot;headerlink&quot; title=&quot;1.1 计算集群&quot;&gt;&lt;/a&gt;1.1 计算集群&lt;/h3&gt;</summary>
    
    
    
    <category term="海边拾贝" scheme="https://thysrael.github.io/categories/%E6%B5%B7%E8%BE%B9%E6%8B%BE%E8%B4%9D/"/>
    
    
    <category term="知识总结" scheme="https://thysrael.github.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="海边拾贝" scheme="https://thysrael.github.io/tags/%E6%B5%B7%E8%BE%B9%E6%8B%BE%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>硬件平台-外存</title>
    <link href="https://thysrael.github.io/posts/dcaf34a0/"/>
    <id>https://thysrael.github.io/posts/dcaf34a0/</id>
    <published>2024-05-04T07:47:22.000Z</published>
    <updated>2024-10-17T06:35:03.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、块设备"><a href="#一、块设备" class="headerlink" title="一、块设备"></a>一、块设备</h2><p>外存是一种块设备（block device），是指以固定大小的块（block）为单位进行读写访问的设备。这些设备以块为最小的访问单元，每个块都有一个唯一的地址。我个人理解，可以将一个块设备理解成以 block 为元素的线性数组。</p><p>其中 block 大小一般是 512 字节，也被叫作扇区 sector。其实这个大小对于现在的计算机有些太小了，所以往往这些 block 也会聚集成一个更大的单位，这里就会产生一些混乱，比如说这个更大的单位可以被叫作簇 cluster，也可以被叫作块 block。</p><p>块设备在 Linux 中显示为 <code>/dev/</code> 下的一个文件，他们命名往往是 <code>xxy</code> ，其中 <code>y</code> 是 <code>a, b, c, d</code> 这样的字母，用于表示相同设备的编号。而 <code>xx</code> 表示设备的种类：</p><ul><li><code>hd</code>：指的是采用 IDE 磁盘接口的磁盘</li><li><code>sd</code>：原本是 SCSI disk，SCSI 和 IDE 都是旧控制器协议，现在也只 SATA 接口的磁盘</li><li><code>vd</code>：虚拟硬件设备，在一些虚拟化平台（如 KVM、QEMU、Xen）中，虚拟化主机的磁盘设备会被命名为 <code>vda</code>、<code>vdb</code>、<code>xvdc</code> 等类似的形式。</li><li><code>nvme</code>：NVMe 是 non-volatile memory express，它是一个主机控制器接口和存储协议，用于加速企业和客户端系统以及固态驱动器（SSD）之间的数据传输。它通过电脑的高速 PCIe 总线工作。总结就是一个比 SATA 快的固态硬盘设备。</li></ul><p>当然我们提供了这些文件，主要是是为了使用他们，我门也不指望可以用 <code>cat</code> 查看他们内容了，但是可以用 <code>dd</code> 对它们进行复制，用 <code>fdisk</code> 对它们进行分区。</p><p>另外还有一种叫作<strong>磁盘镜像</strong>的文件，他们就是磁盘内容的完全复制，也就是说，所有能在 <code>/dev/sda</code> 上进行的操作，都可以在 <code>disk.img</code> 中进行，相当于是把一个磁盘内容作为文件放到了另一个磁盘上。</p><hr><h2 id="二、分区"><a href="#二、分区" class="headerlink" title="二、分区"></a>二、分区</h2><p>一般我们并不会在拿到一个块设备后就立刻使用，而是对它们进行分区，分区的效果就是让一块磁盘看上去像多块磁盘。</p><p>至于为什么要分区，从历史的角度看，分区可能是因为 OS 并不能很好处理容量较大的磁盘，通过分区可以让磁盘分成多个小磁盘，方便 OS 的处理。而当今来看，分区和文件系统密切联系，一个分区上只能有一个文件系统，一个文件系统只能在一个分区上。所以当我们有使用多文件系统的需求时，也就需要分区了。</p><p>而为什么需要多个文件系统，就有很多原因了，比如最为朴素的，希望不同的文件属于不同的文件系统，比如 Windows 就希望所有的软件都在 C 盘中安装。而比较高端的，就是因为不同的文件系统具有不同的性质，比如有些不易失，但是速率较慢，而有些速度块，却很易失，所以就需要用多个文件系统来达到权衡。</p><p>分区的实现依赖于分区表，目前有两种格式的分区表，分别是 MBR 分区表和 GPT 分区表，后者可以创建更多的分区，是一种先进的设计。</p><p>我们可以用 <code>fdisk</code> 或者 <code>gparted</code> 对磁盘进行分区，我截了张图，是 Windows 下的分区</p><p><img src="/posts/dcaf34a0/image-20240504174321947.png" alt="image-20240504174321947"></p><p>这张图基本上直观地反映了这篇博文的所有知识点。这个磁盘有 6 个分区，其中比较重要的 3 个分区分别是 C，D，E 盘。</p><p>有趣的是，分区和磁盘一样，同样会在 <code>/dev/</code> 文件夹下出现，他们的命名格式就是原本的磁盘名字加上数字编号（或者一些其他类似的后缀），当我们使用 <code>lsblk</code> 命令时，会清楚得发现这个关系，如下所示：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ lsblkNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTSnvme1n1     <span class="token number">259</span>:0    <span class="token number">0</span> <span class="token number">476</span>.9G  <span class="token number">0</span> disk ├─nvme1n1p1 <span class="token number">259</span>:1    <span class="token number">0</span>   260M  <span class="token number">0</span> part ├─nvme1n1p2 <span class="token number">259</span>:2    <span class="token number">0</span>    16M  <span class="token number">0</span> part ├─nvme1n1p3 <span class="token number">259</span>:3    <span class="token number">0</span>   100G  <span class="token number">0</span> part ├─nvme1n1p4 <span class="token number">259</span>:4    <span class="token number">0</span> <span class="token number">187</span>.8G  <span class="token number">0</span> part /run/media/thysrael/D├─nvme1n1p5 <span class="token number">259</span>:5    <span class="token number">0</span> <span class="token number">187</span>.8G  <span class="token number">0</span> part /run/media/thysrael/E└─nvme1n1p6 <span class="token number">259</span>:6    <span class="token number">0</span>  1000M  <span class="token number">0</span> part nvme0n1     <span class="token number">259</span>:7    <span class="token number">0</span> <span class="token number">931</span>.5G  <span class="token number">0</span> disk ├─nvme0n1p1 <span class="token number">259</span>:8    <span class="token number">0</span>   300M  <span class="token number">0</span> part /boot/efi└─nvme0n1p2 <span class="token number">259</span>:9    <span class="token number">0</span> <span class="token number">931</span>.2G  <span class="token number">0</span> part /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（另外说一嘴，表头的 <code>MAJ:MIN</code> 指的是主设备号和次设备号）。</p><p>所有可以对磁盘文件使用的命令都可以对分区文件使用，而且分区文件还可以使用 <code>mount</code> 命令。这是因为只有分区因为有文件系统的存在，所以具有“可解释性”。而磁盘并没有这个特性。</p><hr><h2 id="三、文件系统"><a href="#三、文件系统" class="headerlink" title="三、文件系统"></a>三、文件系统</h2><p>分区之后依然没法使用，因为我们还需要对分区进行<strong>格式化</strong>，在 Linux 上我们可以使用命令 <code>mkfs</code> 来进行格式化。正如这个命令本身所暗示的一样，格式化的本质就是在分区上创建一个“文件系统”。</p><p>这里需要区分一下文件系统的概念。事实上，我们会接触到两个文件系统，一个文件系统是我从小就接触到的，它被组织成一棵树型结构，有文件夹，有文件，我可以创建，删除，编辑，在各个路径下导航，这个文件系统是操作系统维护并呈现给我的。还有一个文件系统是我之前很少接触的，他们指的是如何规划分区里面的 block ，在原本线性的 block 数组上，构建一个树形结构，每个节点还存储着一些元数据。此外，还应当考虑这个树形结构的检索、安全、可恢复性、大小等因素。这个文件系统有 FAT, EXT, NTFS 等例子。</p><p>我们格式化生成的就是第二种文件系统，而第一种文件系统更像是第二种文件系统的“<strong>前端</strong>”。这种文件系统由以下几个部分组成：</p><ul><li>file data: 即文件中的数据</li><li>meta data: 除了文件本身包含的数据，还有文件的访问权限、大小和创建时间等控制信息。这也被称为 inode</li><li>control data: 用于记录分区 block 的使用情况和归属情况，可以是位图</li><li>superblock: 包含了一个文件系统所有的控制信息，可以理解为文件系统的 meta data</li></ul><hr><h2 id="四、挂载"><a href="#四、挂载" class="headerlink" title="四、挂载"></a>四、挂载</h2><p>那么如何让一个外存上的文件系统转变成我们常见的<strong>前端文件系统</strong>呢？是通过挂载 mount 。</p><p>挂载指的是在原有的前端文件系统中找到一个目录（也被称为挂载点），然后让 OS 解析外存文件系统，并将其根节点放到挂载点上的过程。之后我们就可以通过访问挂载点下的文件树，来访问实际的文件系统了。</p><p>示意图如下：</p><p><img src="/posts/dcaf34a0/v2-1d745e32b36be641322ac90ea9812978_720w.webp" alt="img"></p><p>以 <code>/home</code> 为挂载点挂载 partition b，效果如图：</p><p><img src="/posts/dcaf34a0/v2-63bc5bc54fda33eef63e5d3102234756_720w.webp" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、块设备&quot;&gt;&lt;a href=&quot;#一、块设备&quot; class=&quot;headerlink&quot; title=&quot;一、块设备&quot;&gt;&lt;/a&gt;一、块设备&lt;/h2&gt;&lt;p&gt;外存是一种块设备（block device），是指以固定大小的块（block）为单位进行读写访问的设备。这些设备以块为最小的访问单元，每个块都有一个唯一的地址。我个人理解，可以将一个块设备理解成以 block 为元素的线性数组。&lt;/p&gt;
&lt;p&gt;其中 block 大小一般是 512 字节，也被叫作扇区 sector。其实这个大小对于现在的计算机有些太小了，所以往往这些 block 也会聚集成一个更大的单位，这里就会产生一些混乱，比如说这个更大的单位可以被叫作簇 cluster，也可以被叫作块 block。&lt;/p&gt;
&lt;p&gt;块设备在 Linux 中显示为 &lt;code&gt;/dev/&lt;/code&gt; 下的一个文件，他们命名往往是 &lt;code&gt;xxy&lt;/code&gt; ，其中 &lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;a, b, c, d&lt;/code&gt; 这样的字母，用于表示相同设备的编号。而 &lt;code&gt;xx&lt;/code&gt; 表示设备的种类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hd&lt;/code&gt;：指的是采用 IDE 磁盘接口的磁盘&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sd&lt;/code&gt;：原本是 SCSI disk，SCSI 和 IDE 都是旧控制器协议，现在也只 SATA 接口的磁盘&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vd&lt;/code&gt;：虚拟硬件设备，在一些虚拟化平台（如 KVM、QEMU、Xen）中，虚拟化主机的磁盘设备会被命名为 &lt;code&gt;vda&lt;/code&gt;、&lt;code&gt;vdb&lt;/code&gt;、&lt;code&gt;xvdc&lt;/code&gt; 等类似的形式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nvme&lt;/code&gt;：NVMe 是 non-volatile memory express，它是一个主机控制器接口和存储协议，用于加速企业和客户端系统以及固态驱动器（SSD）之间的数据传输。它通过电脑的高速 PCIe 总线工作。总结就是一个比 SATA 快的固态硬盘设备。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="硬件平台" scheme="https://thysrael.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="硬件平台" scheme="https://thysrael.github.io/tags/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>硬件平台-Cache</title>
    <link href="https://thysrael.github.io/posts/603a762d/"/>
    <id>https://thysrael.github.io/posts/603a762d/</id>
    <published>2024-05-03T13:21:29.000Z</published>
    <updated>2024-10-17T06:35:03.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、结构"><a href="#一、结构" class="headerlink" title="一、结构"></a>一、结构</h2><p>因为一直分不清 Cache 的结构名字，所以特地画了一个比较满意的图来标注各种结构。</p><p><img src="/posts/603a762d/cache.drawio.png" alt=""></p><p>这个示意图的参数在右上角。Cache 中的基本单位是 Cache Line，它又被叫作 Block，它是由多个 Word 组成的。多个 Cache Line 会组成一个 Cache Set，一个 Cache Set 内包含的 Cache Line 数量被成为 Way。比如图中就是 2-Way 的 Cache，那么每个 Cache Set 就有 2 个 Cache Line。相同 Cache Set 中的 Cache Line 的关系被称为 associative（相联），它们不能依靠 set index 进行区分，只能通过 tag 区分。 </p><p>根据 Set 个数和 Way 的不同（其本质是 Cache Line 的位置确定），可以对 Cache 进行分类：</p><ul><li>直接映射（direct-map）：即 Way = 1 的情况</li><li>组相连（set-associative）：即普通情况</li><li>全相连（fully-associative）：即只有一个 Set，所有的 Cache Line 都是 associative 的。</li></ul><p>他们的功能上的区别在 Cache 的检索和分配上均有体现。会在下面章节进行介绍。</p><hr><h2 id="二、查找"><a href="#二、查找" class="headerlink" title="二、查找"></a>二、查找</h2><h3 id="2-1-过程"><a href="#2-1-过程" class="headerlink" title="2.1 过程"></a>2.1 过程</h3><p>首先补充 Cache 和 CPU 还有内存沟通的数据大小：CPU 每次从 Cache 中取出一个 Word，而 Cache 每次从 Memory 中取出一个 Cache Line。</p><p>CPU 会给 Cache 发送一个地址，这个地址有可能是虚拟地址，也可能是物理地址，这取决于具体的架构实现方式。这个地址还有一个特点是<strong>按照 Word 对齐的</strong>。虽然这个示意图中 Word 只有一个字节，没有对齐的必要，但是在常见的 Word 为 4 个字节的 32 位架构中，这个地址的 <code>[1:0]</code> 一定是 <code>0</code> 。</p><p>交给 Cache 的地址会被分成 3 个部分，即上图的 Tag（蓝色），Index（绿色） 和 Offset（橙色）。检索 Word 的过程是一个“Index-Check-Index”的过程。</p><p>首先我们根据<strong>绿色部分 index</strong> 找到对应的 Cache Set（这是一个像随机地址访问的过程，称之为 Index），因为 Index 是 1，所以我们找到左下角的 Cache Set 1。然后就会发现里面有一堆的 Cache Line，对于这些 Cache Line，我们没有办法直接确定哪一个是我们要找到的 Cache Line，我们需要用地址上的<strong>蓝色部分 Tag</strong> 和 Cache 中的 Tag 进行比对，只有完全相同才是我们要找的 Cache Line，所以我们在此图中选择了第二个 Cache Line（这个过程需要比对所有的 Tag 的所有位，称之为 Check）。在选定 Cache Line 后，我们需要根据<strong>橙色部分 Offset </strong>选择 Cache Line 中具体的 Word，图中 Offset 是 2，所以我们选择第 2 个 Word 交给 CPU（这个过程和绿色部分一样，也是 Index）。</p><p>如果用伪代码描述，是如下过程：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> Word <span class="token operator">=</span> <span class="token keyword">char</span><span class="token punctuation">;</span><span class="token keyword">using</span> CacheLine <span class="token operator">=</span> Word<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">using</span> CacheSet <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span>Tag<span class="token punctuation">,</span> CacheLine<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token keyword">using</span> Cache <span class="token operator">=</span> CacheSet<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Word <span class="token function">find</span><span class="token punctuation">(</span>Tag tag<span class="token punctuation">,</span> Index index<span class="token punctuation">,</span> Offset offset<span class="token punctuation">)</span><span class="token punctuation">{</span>CacheSet set <span class="token operator">=</span> Cache<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>entry <span class="token operator">:</span> set<span class="token punctuation">)</span><span class="token punctuation">{</span>CacheLine line <span class="token operator">=</span> entry<span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>first <span class="token operator">==</span> tag<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> line<span class="token punctuation">[</span>offset<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述过程基本上描述了“一个 Word 是怎样从 Cache 中根据地址被检索出来”的过程，省略的部分主要是对于 Cache Line valid 和 dirty 等属性的检验。</p><p>对于检索成功的情况，我们称之为 hit（命中），而对于检索失败的情况，我们称之为 miss（缺失）。</p><h3 id="2-2-矛盾"><a href="#2-2-矛盾" class="headerlink" title="2.2 矛盾"></a>2.2 矛盾</h3><p>在上述过程中，Index 具有随机访问的特征，所以会比较快，而 Check 需要对 Set 内的每个 Line 的 Tag 进行比对，所以比较慢。Check 和 Way 直接相关，因为 Way 就是 Set 里 Line 的数量，所以 Way 越大，Check 对硬件性能的要求越高（因为比较电路非常耗片上资源，而且存储 Tag 也需要额外的空间）。但是换一个角度思考，当 Way 变大时，我们命中 Cache 的可能性也会变大，因为此时会存在更多候选的 Line 。所以选择多少 Way 其实是需要权衡的。</p><p>当 Cache 的总容量一定（这个比较实际，因为 Cache 总容量跟 Cache 需要消耗的片上资源直接相关）的时候，Way 和 Set 数量是反比关系，所以我们应当考虑好这个矛盾，也就是高命中率（Way 多）和低硬件成本和复杂度（Set 多）。</p><h3 id="2-3-地址翻译"><a href="#2-3-地址翻译" class="headerlink" title="2.3 地址翻译"></a>2.3 地址翻译</h3><h4 id="2-3-1-地址策略"><a href="#2-3-1-地址策略" class="headerlink" title="2.3.1 地址策略"></a>2.3.1 地址策略</h4><p>在上面的介绍中，我们并没有强调我们查找 Cache 的时候的地址是物理地址还是虚拟地址，这是因为这是受到具体的硬件架构设计。具体的策略有 3 种：VIVT、PIPT、VIPT，这里的英文是都是缩写，分别对应 Virtual，Physical，Index，Tag 英文。</p><h4 id="2-3-2-VIVT"><a href="#2-3-2-VIVT" class="headerlink" title="2.3.2 VIVT"></a>2.3.2 VIVT</h4><p>VIVT 指的是完全使用 VA 进行 Cache 查找，这种方式的优势是，在查找前不需要经过 MMU 将 VA 翻译成 PA，命中只需要花费查找的时间，而缺失的时候再经过 MMU 翻译成 PA 进行访存，是非常高效的（因为 MMU 翻译也是很消耗时间的），</p><p>但是缺点有两个：歧义 (ambiguity) 和别名 (alias) 。这其实都是虚拟地址空间本身特性导致的问题。</p><p>歧义指的是<strong>相同的 VA 对应不同的 PA</strong>，这是由于相同的 VA 来自不同的进程地址空间，这就要求 OS 在进程切换的时候需要刷新 Cache，这就导致了切换后会有一个冷启动过程。</p><p>而别名指的是<strong>不同的 VA 对应了相同的 PA</strong>，这是由于虚拟地址可以让不同 VA 映射到相同的 PA 上，别名问题会导致一个 Cache 中可能存在多个物理内存的副本，而当我们更新这些副本的时候，有可能没有更新全部副本，导致操作。解决这个问题的方式就是将这种<strong>共享的 PA</strong> 设置成 nocache 的，即禁止他们使用 Cache。除此之外，似乎还可能用硬件措施解决多副本问题。</p><h4 id="2-3-3-PIPT"><a href="#2-3-3-PIPT" class="headerlink" title="2.3.3 PIPT"></a>2.3.3 PIPT</h4><p>PIPT 指的是完全使用 PA 进行 Cache 查找。因为物理地址具有唯一性，所以就不会存在 VIVT 所面临的歧义和别名问题，OS 的维护难度会直线下降，这部分的维护开销也会被取消。</p><p>但是其缺点就是每次 Cache 查找都需要经过 MMU 翻译，需要承担翻译的开销。但是因为现代的 MMU 有 TLB 加速，所以开销是可以接受的。现代的 Cache 往往采用 PIPT 的形式。</p><h4 id="2-3-4-VIPT"><a href="#2-3-4-VIPT" class="headerlink" title="2.3.4 VIPT"></a>2.3.4 VIPT</h4><p>当我们讨论使用 VA 的缺点时，本质其实在说用于查找的 Tag 和 Index 到底是 Virtual 的还是 Physical 的，如果是 Virtual 的，那么就会有歧义和别名问题，如果是 Physical 的，那么就不会有。</p><p>VIPT 指的是使用 Physical 的 Tag 和 Virtual 的 Index 。这样的好处在于，地址翻译过程和 Cache 查找过程可以并行，在地址翻译还没有结果的时候，我们就可以用 VI 来进行 Cache Set 的确定了。而且这种方式不再有歧义问题了，但是可能有别名问题。</p><p>对于歧义问题，此时的 PT 不再是 PA 的 Tag 部分，而变成了 PPN，PPN 具有唯一性，所以不再有歧义问题。</p><p>而对于别名问题，则要分类讨论，因为 Index 依然是虚拟的，那么使用 PPN 作为 Tag 能否矫正 VI 的影响呢？这要看 PPN 的宽度（反过来也可以说看 Index 的宽度），如下所示：</p><p><img src="/posts/603a762d/VIPT.drawio.png" alt=""></p><p>如果是第一种情况，VI 和 PI 存在差异，所以就会有别名现象，而第二种情况，VI 和 PI 不存在差异，就不会有别名现象。</p><p>总结就是 PPN 和 Index 不能有交集，就不会有问题。</p><hr><h2 id="三、分配与更新"><a href="#三、分配与更新" class="headerlink" title="三、分配与更新"></a>三、分配与更新</h2><h3 id="3-1-分配的情形"><a href="#3-1-分配的情形" class="headerlink" title="3.1 分配的情形"></a>3.1 分配的情形</h3><p>当我们考虑将一个 CacheLine 从 Memory 中填充到 Cache 中时，这个 CacheLine 一定会被确定地放到某个 CacheSet 中，但是具体是哪个 CacheLine Slot，那就不一定了，我们有 Way 种选择。</p><p>其实原本的 CacheSet 中的 CacheLine Slot 也有 3 种情况，第一种是这个 slot 是空的，那么 CacheLine 放到这里就好了。第二种是这个 slot 本来就放着 这个待插入的 CacheLine，那么什么都不用干就好了。最后一种是这个 Slot 本来就放着一个不同的 CacheLine，那么就需要把原本的 CacheLine 逐出（evictation）。至于选择 set 中的哪个 line 逐出，基本上我们采用 LRU 策略来决定。</p><p>从逐出角度考虑，当 Way 增大的时候，CacheLine 的选择会更加灵活，逐出会更少。</p><p>从宏观角度看，逐出的存在是因为 Cache 比 Memory 小。如果 Index 的宽度是地址宽度减去 Offset 宽度，那么就不存在逐出了，很可惜事实并不是这样。相同 Index 的 CacheLine 会被分配到同一个 set 中，而 Way 只是提供了一种逐出的“缓冲”。</p><h3 id="3-2-Index-Position-分析"><a href="#3-2-Index-Position-分析" class="headerlink" title="3.2 Index Position 分析"></a>3.2 Index Position 分析</h3><p>在示意图上展示的 Index 在低位，而 Tag 在高位。这样做的效果就是，一些地址相近的数据（也就是高位地址相同），会被分散到各个 Set 中，这无疑是好的。因为程序具有局部性，地址相近的数据大概率会被反复用到，如果将它们分配到同一个 Set 中，那么就会导致它们互相挤占（Evictation），导致命中率降低。</p><h3 id="3-3-分配策略"><a href="#3-3-分配策略" class="headerlink" title="3.3 分配策略"></a>3.3 分配策略</h3><p>cache 的分配策略（allocation policy）是指我们什么情况下应该为数据分配 cache line，也就是合适从内存中将数据取出来放到 cache 中。分为<strong>读分配策略和写分配策略</strong>。</p><p>读分配策略指的是当 CPU 读数据时，发生 cache 缺失，这种情况下都会分配一个 cache line 缓存从主存读取的数据。默认情况下，cache 都支持读分配。</p><p>当 CPU <strong>写数据</strong>发生 cache 缺失时，才会考虑写分配策略。当我们不支持写分配的情况下，写指令只会更新 Memory 数据，然后就结束了。当支持写分配的时候，我们首先从 Memory 中加载数据到 cache line 中（相当于先做个读分配动作），然后会更新 cache line 中的数据。</p><p>Cache 对读写的加速副作用是不一样的，Cache 加速写操作，如果采用写分配策略，那么就会有可能导致 Cache 和 Memory 中的数据存在差异（具体取决于更新策略）。</p><h3 id="3-4-更新策略"><a href="#3-4-更新策略" class="headerlink" title="3.4 更新策略"></a>3.4 更新策略</h3><p>更新策略（update policy）指的是，当<strong>写操作（Store）</strong>命中 Cache 时，Cache 应当如何更新其中的数据。有写直通（write through）和写回（write back）两种策略。</p><p>写直通指的是当 CPU 执行 store 指令并在 cache 命中时，我们更新 cache 中的数据并且更新 Memory 中的数据。<strong>cache和 Memory 的数据始终保持一致</strong>。</p><p>当 CPU 执行 store 指令并在 cache 命中时，我们只更新 cache 中的数据。并且每个 cache line 中会有一个 bit 位记录数据是否被修改过，称之为dirty bit。Memory 中的数据只会在 cache line 被逐出或者显式的 clean 操作时更新。因此，<strong>cache 和 Memory 的数据可能不一致</strong>。</p><hr><h2 id="四、一致性"><a href="#四、一致性" class="headerlink" title="四、一致性"></a>四、一致性</h2><h3 id="4-1-嗅探"><a href="#4-1-嗅探" class="headerlink" title="4.1 嗅探"></a>4.1 嗅探</h3><p>缓存嗅探（cache snoop）是一种处理器或核心之间进行协作的机制，用于<strong>维持多级缓存的一致性</strong>。当一个处理器核心通过读取或写入特定的内存地址时，缓存嗅探是用来检测其他处理器核心的缓存中是否存在该数据的过程。</p><p>当一个处理器核心在进行读取或写入操作时，它会发出一个嗅探请求，通知其他处理器核心进行检查它们各自的缓存，以确定是否存在与当前操作相关的数据。根据嗅探的结果，其他核心会执行以下操作之一：</p><ol><li><p>无效（Invalidation）：如果其他核心的缓存中存在与当前操作相关的数据，并且该数据被标记为有效，则其他核心会将其无效化，即将其标记为无效状态。这确保了所有核心都具有相同的缓存状态。</p></li><li><p>更新（Updating）：如果其他核心的缓存中存在与当前操作相关的数据，并且该数据被更改或写入，则其他核心会将其更新为新的值，以保持缓存的一致性。</p></li></ol><p>通过缓存嗅探机制，不同核心之间能够及时地检测到彼此的缓存状态，从而保持缓存的一致性。这在多核处理器和多处理器系统中非常重要，因为它确保了多个处理器核心之间的共享数据的正确性，并避免了数据不一致的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、结构&quot;&gt;&lt;a href=&quot;#一、结构&quot; class=&quot;headerlink&quot; title=&quot;一、结构&quot;&gt;&lt;/a&gt;一、结构&lt;/h2&gt;&lt;p&gt;因为一直分不清 Cache 的结构名字，所以特地画了一个比较满意的图来标注各种结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/603a762d/cache.drawio.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这个示意图的参数在右上角。Cache 中的基本单位是 Cache Line，它又被叫作 Block，它是由多个 Word 组成的。多个 Cache Line 会组成一个 Cache Set，一个 Cache Set 内包含的 Cache Line 数量被成为 Way。比如图中就是 2-Way 的 Cache，那么每个 Cache Set 就有 2 个 Cache Line。相同 Cache Set 中的 Cache Line 的关系被称为 associative（相联），它们不能依靠 set index 进行区分，只能通过 tag 区分。 &lt;/p&gt;
&lt;p&gt;根据 Set 个数和 Way 的不同（其本质是 Cache Line 的位置确定），可以对 Cache 进行分类：&lt;/p&gt;</summary>
    
    
    
    <category term="硬件平台" scheme="https://thysrael.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="硬件平台" scheme="https://thysrael.github.io/tags/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>信息安全-旁路攻击</title>
    <link href="https://thysrael.github.io/posts/d867fb6e/"/>
    <id>https://thysrael.github.io/posts/d867fb6e/</id>
    <published>2024-04-05T12:51:26.000Z</published>
    <updated>2024-10-17T06:35:01.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><p>旁路攻击（Side Channel Attack）指的是利用计算机通信过程中产生的“副作用”发起的攻击。也就是说，攻击者没有选择像监听信道或者破解密码等“正面手段”，而是利用通信时的时延、电压变化、能耗变化、JTag、异常等“边缘特征”等来发起攻击，是一种“侧面突破”。</p><p>我个人感觉旁路攻击利用的边缘特征，往往都是在根本上无法避免的特征，我们并不能为了避免时延旁路攻击，就放弃使用 Cache，或者为了 JTag 旁路攻击，就放弃使用硬件调试，甚至为了避免能耗攻击，就不用电了？这也就意味着，不像加密一样，只要提出了一个破密复杂度极高的加密算法，就可以一劳永逸。旁路攻击的防范是不能停歇的，任何一个计算机系统运行产生的效果，都会导致一次可能的攻击。</p><p>为了解释一下定义，旁路实际上是因为边缘特征产生的信息通道，就叫旁路。</p><hr><h2 id="二、时延旁路攻击"><a href="#二、时延旁路攻击" class="headerlink" title="二、时延旁路攻击"></a>二、时延旁路攻击</h2><p>缓冲时延（Cache Timing）旁路是通过内存访问时间的不同来产生的旁路。这个原理也非常好理解，在现代体系结构中，Cache 可以加速 CPU 对于内存的访问，只要 CPU 访问过一个地址的数据，Cache 就可以加载这次的数据，当下次 CPU 再访问这个地址的数据时，Cache 就可以快速地把这个数据递交给 CPU。</p><p>所以我们其实是可以知道 CPU 前一段时间访问了<strong>哪个地址</strong>，这是因为如果我们再次访问的话，会发现访问的时延很短，这是因为之前访问过了，数据在 Cache 中。这种“知晓”是不受到普通的隔离机制防范的，用户可以借此查看内核之前访问过的地址，或者是查看另一个用户访问的地址（当然还需要一些辅助构造手段）。因为隔离机制往往只隔离了内存和 CPU，而对于 Cache，则没有隔离效果。</p><p>朴素地想，知道地址并不是一件很危险的事情，比如说我知道了我想要窃取的数据 <code>secret</code> 的地址是 <code>0x0030</code> ，那我也无计可施，我又没有 <code>0x0030</code> 对应的页表（内核页表或者另一个用户程序的页表），Cache 中就算预存了 <code>secret</code> ，我也拿不出来。</p><p>不过换一个角度去想，如果攻击方可以诱导被攻击方用 <code>secret</code> <strong>作为地址</strong>去访问数据就好了，这样攻击方就可以直接知道 <code>secret</code> 内容了。那么应该怎么诱导呢？凭什么被攻击方就听攻击者的了？根据实现的不同，又分为了 Meltdown 和 Spectre 两种实现。Meltdown 从用户程序攻击内核，Spectre 则更加通用，也可以从用户程序攻击另一个另一个用户程序。总结如下：</p><p><img src="/posts/d867fb6e/image-20240407000737679.png" alt="image-20240407000737679"></p><p>其中 Meltdown 利用的是，在异常发生时，CPU 会立刻切换到内核态，但是因为乱序执行的缘故，攻击者在异常发生后的紧邻的几条指令会在内核态得到执行，只是它们不会被提交，它们会在后续被 CPU 作废处理，但是已经在 Cache 中留下痕迹了，这就足够发动攻击了。</p><p>具体代码如下：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; [rcx] is kernel secret; rbx is probe basemeltdown:mol al, byte [rcx] ; rax = secret, raise excptionshl rax, 0xc ; rax *= 4096, sparse the cache linejz meltdown ; meltdown for unzero secretmov rbx, qword [rbx + rax] ; read probe[secret], cache remeber! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中第 2，3 条指令都是具体优化，核心是第 1，4 条指令，可以看到我们先访问了一个内核的机密数据，这个机密数据的地址是 <code>rcx</code>，当然内核肯定不让我们访问，会触发异常，但是没有关系，在触发异常后虽然我们得不到具体的 <code>secret</code> 也就是 <code>[rcx]</code>，但是因为乱序执行的缘故，第 4 条指令有可能会被执行，也就是说，攻击者程序中的 <code>probe[secret]</code> 这一个元素会被访问，下次我们再访问这个 <code>probe[secret]</code> 的时候，我们的访问速度就会变快，我们只需要遍历 <code>probe</code> 所有元素测试访问速度，找到最快的元素，它的编号就是 <code>secret</code> 。</p><p>其中第 2 条指令用于放大 <code>secret</code> “信号”，避免 cache 加速了多个 <code>probe</code> 元素的访问，使 Cache 只能加速一个元素的访问。第 3 条指令用于判断第 4 条指令是否执行，因为如果 CPU 反应快，会立刻将 <code>rax</code> 注销清 0，那么就需要再次尝试，所以这里有个循环。</p><p>按 Meltdown 论文的说法，他们在 Intel 的 CPU 上可以用五百多 K 每秒的速度 Dump 内核映像！</p><p>Sepecture 基于类似的原理</p><p><img src="/posts/d867fb6e/image-20240407002611613-17124207742361.png" alt="image-20240407002611613"></p><p>利用数组越界访问来诱导 CPU 执行指令。这幅图中的 <code>Instrument</code> 就是 Meltdown 中的 <code>prob</code> 。<code>A[x]</code> 对应 <code>secret</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、总论&quot;&gt;&lt;a href=&quot;#一、总论&quot; class=&quot;headerlink&quot; title=&quot;一、总论&quot;&gt;&lt;/a&gt;一、总论&lt;/h2&gt;&lt;p&gt;旁路攻击（Side Channel Attack）指的是利用计算机通信过程中产生的“副作用”发起的攻击。也就是说，攻击者没有选择像监听信道或者破解密码等“正面手段”，而是利用通信时的时延、电压变化、能耗变化、JTag、异常等“边缘特征”等来发起攻击，是一种“侧面突破”。&lt;/p&gt;
&lt;p&gt;我个人感觉旁路攻击利用的边缘特征，往往都是在根本上无法避免的特征，我们并不能为了避免时延旁路攻击，就放弃使用 Cache，或者为了 JTag 旁路攻击，就放弃使用硬件调试，甚至为了避免能耗攻击，就不用电了？这也就意味着，不像加密一样，只要提出了一个破密复杂度极高的加密算法，就可以一劳永逸。旁路攻击的防范是不能停歇的，任何一个计算机系统运行产生的效果，都会导致一次可能的攻击。&lt;/p&gt;
&lt;p&gt;为了解释一下定义，旁路实际上是因为边缘特征产生的信息通道，就叫旁路。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="信息安全" scheme="https://thysrael.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="知识总结" scheme="https://thysrael.github.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    <category term="信息安全" scheme="https://thysrael.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>硬件平台-Trampoline</title>
    <link href="https://thysrael.github.io/posts/52d3ca8/"/>
    <id>https://thysrael.github.io/posts/52d3ca8/</id>
    <published>2024-04-05T08:41:52.000Z</published>
    <updated>2024-10-17T06:35:03.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、比喻"><a href="#一、比喻" class="headerlink" title="一、比喻"></a>一、比喻</h2><p>Trampoline 指的是“蹦床”，也就是底下这个东西：</p><p><img src="/posts/52d3ca8/aHR0cHM6Ly93d3cuYmVyZ3RveXMuY29tL2NyYWZ0L21lZGlhL2Jhbm5lcnMvXzE1MzR4ODAwX2Nyb3BfY2VudGVyLWNlbnRlcl9ub25lL1RyYW1wb2xpbmVzX1Byb0JvdW5jZXJfMi5qcGc.jpeg" alt="BERG Champion - Rectangular, round and oval trampolines"></p><p>他是一种很有趣的比喻，人们不能直接跳到高空中，而是需要先往下跳，然后借助蹦床的弹力跳到高空中。</p><p>这个比喻出现在用户态和内核态的相互转变中，转变不能直接发生，而是必须要借助一个“蹦床”机制。</p><hr><h2 id="二、RISCV-蹦床"><a href="#二、RISCV-蹦床" class="headerlink" title="二、RISCV 蹦床"></a>二、RISCV 蹦床</h2><p>RISCV 在虚拟地址翻译方面，描述页表基地址只有 <code>satp</code> 没有 <code>uatp</code> 基地址，也就是说，内核和用户程序都只使用 <code>satp</code> 一个寄存器。这点不同于 Armv8 ，所有的用户程序使用 <code>ttbr0</code> ，而内核程序使用 <code>ttbr1</code> 。</p><p>RISCV 的这种节省就导致了一个在内核态转变为的问题：内核态向用户态转变时，需要用软件切换页表，但是“切换页表”这个动作也是由一句代码实现的，这个代码被放在哪里呢？如果只能在用户页表下可以访问，那么从用户页表切换到内核页表之后，这句“切换页表”的代码之后的代码就无法访问了，所以我们必须保证在用户页表和内核页表中都能访问到这句“切换页表”及其前后的代码，并且他们映射到同一个虚拟地址。 <code>trampoline</code> 就是上述放置“切换页表”代码的地方。</p><p>不过在 Armv8 中就没有这个问题，是因为即使在内核态向用户态转变，使用一条指令切换了页表基地址，这只不过是修改了 <code>ttbr0</code> 的内容，内核虚拟地址翻译所依赖的 <code>ttbr1</code> 并没有受到影响。</p><hr><h2 id="三、KPTI-蹦床"><a href="#三、KPTI-蹦床" class="headerlink" title="三、KPTI 蹦床"></a>三、KPTI 蹦床</h2><p>Kernel Page-Table Isolation 是一项 Linux 内核功能，可缓解 Meltdown 安全漏洞（主要影响 Intel 的x86 CPU），并改进了针对绕过内核地址空间布局随机化 (KASLR) 尝试的内核强化。</p><p>具体来说，就是用户态向内核态切换时（比如发生异常），地址空间并不会立刻切换成完全的内核空间，而是先切换到一个只包含最基本 EL0 到 EL1入口和出口代码的向量表等信息映射的地址空间，然后再切换到一个包含全部内核的地址空间。</p><p><img src="/posts/52d3ca8/1024px-Kernel_page-table_isolation.svg.png" alt="undefined"></p><p>之所以这种方法可以防止 meltdown，是因为 meltdown 那条“窃取指令”紧紧贴着引发内核态转换的指令，所以那个时候窃取指令实际发挥作用的地址空间就会变成 trampoline 地址空间。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、比喻&quot;&gt;&lt;a href=&quot;#一、比喻&quot; class=&quot;headerlink&quot; title=&quot;一、比喻&quot;&gt;&lt;/a&gt;一、比喻&lt;/h2&gt;&lt;p&gt;Trampoline 指的是“蹦床”，也就是底下这个东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/52d3ca8/aHR0cHM6Ly93d3cuYmVyZ3RveXMuY29tL2NyYWZ0L21lZGlhL2Jhbm5lcnMvXzE1MzR4ODAwX2Nyb3BfY2VudGVyLWNlbnRlcl9ub25lL1RyYW1wb2xpbmVzX1Byb0JvdW5jZXJfMi5qcGc.jpeg&quot; alt=&quot;BERG Champion - Rectangular, round and oval trampolines&quot;&gt;&lt;/p&gt;
&lt;p&gt;他是一种很有趣的比喻，人们不能直接跳到高空中，而是需要先往下跳，然后借助蹦床的弹力跳到高空中。&lt;/p&gt;
&lt;p&gt;这个比喻出现在用户态和内核态的相互转变中，转变不能直接发生，而是必须要借助一个“蹦床”机制。&lt;/p&gt;</summary>
    
    
    
    <category term="硬件平台" scheme="https://thysrael.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="硬件平台" scheme="https://thysrael.github.io/tags/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成-内存一致性</title>
    <link href="https://thysrael.github.io/posts/6c683641/"/>
    <id>https://thysrael.github.io/posts/6c683641/</id>
    <published>2024-03-19T02:14:56.000Z</published>
    <updated>2024-10-17T06:35:03.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、一致性"><a href="#一、一致性" class="headerlink" title="一、一致性"></a>一、一致性</h2><p>一致性（consistency）这个概念应该是来自于分布式理论的 CAP 理论</p><p><img src="/posts/6c683641/0.jpg" alt="CAP 理论"></p><p>我觉得用人话来说就是对于<strong>多个观察者观察同一个事物</strong>，每个观察者观察到的现象是“相同的”，那么我们就认为这个设计具有“一致性”。“盲人摸象”就是一个非一致性的例子，对于同一个事物，盲人们分别给出了“柱子、山、石头”等描述，就是不具有一致性的案例。</p><p>一致性和并行编程联系紧密，因为一致性保证了多个并行的实体，他们看到的共享资源是相同的。只有这样才能保证并行实体间的协作，如果实体看到的资源都是不一样的，比如说线程 A 给资源加了个锁，但是 B 没有看到这个锁，那么就会导致数据竞争的发生。盲人摸象的结局不正是因为盲人们对于大象的看法各执己见，最终大打出手吗？</p><p>不过一致性中要求的“相同”，也并不意味着“完全一样”，因为“完全一样”并不好达到，比如说正常人去看大象，其实看到的同一个大象也是不同的，比如有人会看见大象的正脸，而有人看见了大象的屁股，白天去看的人和晚上去看的人看到的也不同，追求大家看到的都一样，其实是很困难的。但是大家却能根据看到的不同的大象确定那是同一个大象，这就足够了。</p><p>在并行编程也是一样，“一致性”并非一个定性的概念，而是一个“定量”概念，有些设计是“严格一致性”的，那么大家看到的现象就是非常一致的，而“宽松一致性”会使得大家看到的现象不那么一致。不过并非在“宽松一致性”下就完全没法编程了，而只是说编程时要考虑的问题更多了，更容易出现 bug 了。</p><p>“宽松一致性”的优点在于其他方面会更加有优势，也就是 CAP 中如果牺牲掉 C 这个特性，那么 AP 特性就都会得到增强。在并行编程方面，如果一致性弱的话，那么并行程度就会高，性能就会提升。</p><hr><h2 id="二、内存一致性模型"><a href="#二、内存一致性模型" class="headerlink" title="二、内存一致性模型"></a>二、内存一致性模型</h2><p>内存一致性指的是当内存成为共享资源时，也就是存在多个实体读取同一个内存时，每个实体所看到的内存具有一定的相似特征，使得这些实体之间可以进行协作，不至于产生数据竞争。</p><p>上文提到的实体，其实有两种，一种是软件实体，他们由函数库提供，也就是“软件线程”；另一种是硬件实体，也就是共享内存的多个处理器核。软件线程可以看作是对应硬件多核的封装（当然即使是单核硬件也可以有软件多线程），它相比硬件多核的概念要更加简单和好理解，二者的关系如图：</p><p><img src="/posts/6c683641/2024-03-19_16-11.png" alt="联系"></p><p>我们这次的讨论主要集中于硬件多核处理器所面对的内存一致性模型。</p><p>所以到底什么是“一致性模型”？我觉得它是一组规范或者说协议，它规定了多核处理器面对共享内存时可能出现的现象，软件开发者需要根据规范中的所有“一致”的情况，编写出正常运行的软件。需要强调的是，这里说的“一致”是在一致性模型中定义的“一致”，而不是完全符合直觉的“一致”。一致性模型中定义的“一致”，往往是比直觉中的“一致”要更加弱一些。</p><p>为什么会存在这种差异呢？因为直觉中的“一致”过于理想了，这种理想就类似于让每个人看见的大象都是一模一样的，一致性越是符合直觉，硬件的开销就会越大，性能就会降低；但是如果一致性稍微弱一些，那么硬件的开销就会减少，性能就会提高，但是也会因为不符合人的直觉，导致软件的开销增大。</p><p>我们将内存一致性模型问题定义得更形式化一点，也就是每一个处理器核都在向共享内存进行读写操作，我们需要给这些所有的读写操作线性排序，这个排好的序列对于每个处理器核应该是具有一致性的，也就是应该“差不多”。</p><p>需要强调的是，内存一致性的一些概念和 CAP 一致性中的概念并不兼容，可能是由于他们分别是从不同的场景中演化出来的，所以有一些差异，但是核心是为了理解一致性本身。</p><hr><h2 id="三、严格模型"><a href="#三、严格模型" class="headerlink" title="三、严格模型"></a>三、严格模型</h2><h3 id="3-1-严格一致性"><a href="#3-1-严格一致性" class="headerlink" title="3.1 严格一致性"></a>3.1 严格一致性</h3><p>严格一致性（strict memory）是最为严格的一致性模型，它具有如下特点（也可能还有别的）：</p><ul><li>每个操作都是原子的</li><li>操作在时间上满足全序关系，而且全序关系对每个核心都相同</li><li>每个写操作都立刻对所有核心可见</li><li>线程内操作保持原本的顺序，多个核心的操作可以相互交叉</li></ul><p>这个模型是超级理想的，其实实现起来非常困难。原子性实际实际上在说不允许有两个操作同时发生，全序关系完全相同就是对于“一致性”的描述。而每个写操作都需要同步到其他核心，这要求有一个强大的全局时钟和一个强大的通知机制，这也会导致开销超级大。</p><p>它的示意图如下：</p><p><img src="/posts/6c683641/consistency1.drawio.png" alt=""></p><p>这个模型由于过于理想，所以在硬件层面并没有对应的实现。不过这个模型我个人觉得非常接近软件编程的中的内存一致性模型，只要有了这个模型，我们就可以基于此构造软件所，保证软件线程的协同工作。</p><p>另外需要强调的是，这个模型虽然很理想了，但是看上去也很无序，比如所有核心可以随机交替运行，这一次的运行结果是 $A1 \rightarrow A2 \rightarrow B1 \rightarrow A3 \rightarrow B2 \rightarrow B3$ ，下一次的结果也可能是 $A1 \rightarrow B1 \rightarrow A2 \rightarrow B2 \rightarrow A3 \rightarrow B3$ 。并不能能说这种无序性是一种“不一致性”的体验</p><h3 id="3-2-序列一致性"><a href="#3-2-序列一致性" class="headerlink" title="3.2 序列一致性"></a>3.2 序列一致性</h3><p>序列一致性（sequence memory，SC）相比于严格一致性较为宽松，相比于严格一致性，它不再要求“所有操作立刻可见”的特性，这就不需要全局时钟和通知机制了。其他要求和严格一致性相同，示意图如下：</p><p><img src="/posts/6c683641/consistency2.png" alt=""></p><p>“不再要求所有操作立刻全局可见”意味着不存在全局时钟，那么就会发生上图所描述的行为。明明实际上 $B1$ 先于 $A2$ ，但是在全局视角下，$A2$ 是先于 $B1$ 的。</p><p>这种模型在现实中有一个很好的对照，那就是 Git，最终云端的提交记录历史中，并不是在本地的提交时间靠前，在云端的提交历史中就靠前，可能有的本地提交在时间上较晚，但是和云端同步较早，这样再最终的提交历史中就是比较靠前的。</p><p>虽然放松了限制，但是这种模型依然是“过于理想”了，所以在现实的硬件中并没有这样的实现。这两种模型都被成为严格模型，基本上只出现在理论分析中。</p><p>我们在分析中一般只讨论序列一致性，严格一致性都比较少提及，这是因为序列一致性相比于严格一致性，基本上只有优点而没有缺点，缺少全局时钟导致的核心间无序交织现象，在严格一致性中同样存在，严格一致性在内存模型中变得没有讨论的必要，但是这并不意味着在其他背景下二者没有分别。</p><hr><h2 id="四、宽松模型"><a href="#四、宽松模型" class="headerlink" title="四、宽松模型"></a>四、宽松模型</h2><h3 id="4-1-宽松"><a href="#4-1-宽松" class="headerlink" title="4.1 宽松"></a>4.1 宽松</h3><p>模型的宽松指的是有序性再度减少，这样的好处在于当有序性减少时，并行程度就会提高，性能就会提升，但是就需要软件编程人员更加耗费心力的编程。</p><p>其实在严格模型中核心间已经是无序的了，如果更加无序，那么就是核心内的顺序发生更改，如图所示：</p><p><img src="/posts/6c683641/consistency3.png" alt=""></p><p>但是这其实有些反直觉了，因为我们都知道一个核心即使是乱序的，但是在提交的时候也要顺序提交，为什么这里却可以乱序呢？这是因为这里并不是提交而是访存，即使是顺序提交的，但是在访存的时候却可以是乱序的。</p><p>而事实上，访存的时候真的是乱序的。因为在处理器内部，为了提高并行度，在 cache 之上增设了一层 store buffer 的结构，用于缓存 store 指令（也就是内存 write 指令），store buffer 作为一个 buffer，会在合适的时机将其中的指令应用到内存系统中，对于对同一地址的多次写操作可以合并，对于内存读操作可以查找，而且还不阻塞处理器流水线，是非常有用的结构，如下所示：</p><p><img src="/posts/6c683641/image-20240319223411641-17108588532272.png" alt="image-20240319223411641"></p><p>但是这就导致了内存读写指令的乱序问题，对内存的读写指令开始变得乱序，一共有 4 种乱序形式（为了表达的方便，我们用 $X \rightarrow Y$ 来表示应该先 $X$ 后 $Y$）：</p><ul><li>乱序 $Write \rightarrow Read$：也就是原本应该先写后读，现在读指令提前了。</li><li>乱序 $Write \rightarrow Write$</li><li>乱序 $Read \rightarrow Write$</li><li>乱序 $Read \rightarrow Read$</li></ul><p>再次强调，这里说的乱序指的是单个核心内的乱序，或者说是，在一个观察者视角，看一个核心向外发出的读写请求的顺序和原本程序员视角下的顺序不一致的情况，并不涉及多个核心。</p><h3 id="4-2-TSO-模型"><a href="#4-2-TSO-模型" class="headerlink" title="4.2 TSO 模型"></a>4.2 TSO 模型</h3><p>完全存储定序模型（Total Store Order）指的是仅可以进行  $Write \rightarrow Read$ 乱序，这种乱序基本上已经是最为严格的宽松模型了，但是依然会出现违反直觉的现象，如下所示：</p><p><img src="/posts/6c683641/consistency4.png" alt=""></p><p>如果按照 SC 模型，那么 <code>data1, data2</code> 都会被读出一到二个会为 <code>NEW</code>，但是如果是 TCO 模型，那么很容易发生两个 <code>data</code> 都被读出 <code>INIT</code> 的情况。</p><h3 id="4-3-PSO-模型"><a href="#4-3-PSO-模型" class="headerlink" title="4.3 PSO 模型"></a>4.3 PSO 模型</h3><p>部分存储定序模型（Partial Store Order）指的是可以进行 $Write \rightarrow Read$ 和 $Write \rightarrow Write$ 乱序。如果进一步放松，会得到其他模型。</p><h3 id="4-4-屏障指令"><a href="#4-4-屏障指令" class="headerlink" title="4.4 屏障指令"></a>4.4 屏障指令</h3><p>宽松模型会导致编程难度极具增加，不过其实也不是那么危险，我们保证不发生数据竞争，并不需要在编程的时候时时刻刻注意，我们只需要在一些关键部位小心即可，如下所示，只要在进入和退出临界区的时候注意一下，基本上我们就可以享受宽松模型带来的高效率了。</p><p><img src="/posts/6c683641/v2-e9d42741df9e3e37d9322c8fcb686747_720w.webp" alt="img"></p><p>不过临界区的多线程协作怎么实现呢？硬件其实提供了一种指令来避免乱序行为，也就是“屏蔽指令”。它就像是不可逾越的屏障，后面的read/write 绝不允许越过屏障指令前执行。当然面前的 read/write 也不能越界到它的后面执行。但是屏蔽指令前面的 read/write 操作怎么乱序就管不着了，同样屏蔽指令后面的 read/write 操作也管不着。</p><p><img src="/posts/6c683641/consistency5.png" alt=""></p><p>需要注意，屏蔽指令是针对核心内的乱序，并不是核心外的乱序，它的作用更像是将一个宽松模型重新限制回严格模型，但是对于严格模型如何协作其实是没有帮助的。</p><p>此外，屏障指令也可以被理解成同步指令，所谓的同步，就是让每个核心的看到的共享内存都变得一致（事实上是不一定的，这是因为每个核心都有私有缓存，可能有些写操作还没有作用到内存）。至于为什么屏障有这个能力，这是因为屏障要求所有在屏障指令前的指令都必须在屏障指令前发生作用，这使的屏障指令可以起到强制更新的作用。</p><p>我们用 Java 来举个例子（JVM 怎么不能算是一种硬件架构呢？）：</p><p>如果一个变量由 <code>volatile</code> 修饰，Java 内存模型（JMM）将在对这个变量的写操作后插入一个写屏障指令（同步到共享内存），在读操作前插入一个读屏障指令。这意味着如果你对一个 <code>volatile</code> 变量进行写操作，你必须知道：</p><ol><li>一旦你完成写入，任何访问这个字段的线程将会得到最新的值。</li><li>在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、一致性&quot;&gt;&lt;a href=&quot;#一、一致性&quot; class=&quot;headerlink&quot; title=&quot;一、一致性&quot;&gt;&lt;/a&gt;一、一致性&lt;/h2&gt;&lt;p&gt;一致性（consistency）这个概念应该是来自于分布式理论的 CAP 理论&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/6c683641/0.jpg&quot; alt=&quot;CAP 理论&quot;&gt;&lt;/p&gt;
&lt;p&gt;我觉得用人话来说就是对于&lt;strong&gt;多个观察者观察同一个事物&lt;/strong&gt;，每个观察者观察到的现象是“相同的”，那么我们就认为这个设计具有“一致性”。“盲人摸象”就是一个非一致性的例子，对于同一个事物，盲人们分别给出了“柱子、山、石头”等描述，就是不具有一致性的案例。&lt;/p&gt;
&lt;p&gt;一致性和并行编程联系紧密，因为一致性保证了多个并行的实体，他们看到的共享资源是相同的。只有这样才能保证并行实体间的协作，如果实体看到的资源都是不一样的，比如说线程 A 给资源加了个锁，但是 B 没有看到这个锁，那么就会导致数据竞争的发生。盲人摸象的结局不正是因为盲人们对于大象的看法各执己见，最终大打出手吗？&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成" scheme="https://thysrael.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="知识总结" scheme="https://thysrael.github.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="计算机组成" scheme="https://thysrael.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>语言高阶-转义字符</title>
    <link href="https://thysrael.github.io/posts/680ca445/"/>
    <id>https://thysrael.github.io/posts/680ca445/</id>
    <published>2024-03-14T02:42:33.000Z</published>
    <updated>2024-10-17T06:35:03.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、可打印字符"><a href="#一、可打印字符" class="headerlink" title="一、可打印字符"></a>一、可打印字符</h2><p>转义字符的意思是，原本这个字符表达一个意思，而经过转义后，就会表达另一个意思。原本的意思没有什么特别之处（比如说必须是一个普通字符，一个通配符，一个格式控制符），表达出来的另一个意思也同样没有什么特别之处。</p><p>那么为什么要存在转义字符？我们可以用另一个字符来表达更多的意思，而不是让一个已经有一个意思的字符，经过转义后来表达另一个意思。但是可悲的是，这并不是现实的，现实是，我们仅有数量不多的可打印字符，而我们却希望表达更多的意思（这点在正则中尤其明显）。事实就是，每一个可打印字符都有了自己的含义，我们所能做到的，就只是复用他们。</p><p>上面的说法有些绝对，却是有方法可以缓解这种方式，比如用 Java 中数字编码转义字符，如 <code>\uF890</code> 这种，可以避免复用的尴尬，不过这样又有些不直观，毕竟谁都喜欢写 <code>\n</code> 而不是 <code>\10</code> 。</p><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><p>转义字符的另一个误区是，所有转义字符遵循的规则是相同的。实际上根据转义字符所在的上下文不同，其含义也会发生变化，比如如果一个 <code>.</code> 出现在了 C string 中，那么就是个英文句号，但是如果出现在了正则表达式中，那么就表示<strong>匹配任意字符</strong> 。</p><h3 id="2-1-ASSIC"><a href="#2-1-ASSIC" class="headerlink" title="2.1 ASSIC"></a>2.1 ASSIC</h3><p>ASSIC 主要解决的问题是一些字符并不是可见字符，但是同样需要被记录。比如说换行符 <code>\n</code> 或者颜色控制字符 <code>\e[1;33m</code> 之类的。转义字符将一个可见字符转义来表示一个控制字符。</p><p>此外，因为 <code>\</code> 用来表示转义，那么 <code>\</code> 本身的含义就没法表示了，所以我们会用 <code>\\</code> 表示原本的反斜杠 <code>\</code> 。</p><h3 id="2-2-字符串"><a href="#2-2-字符串" class="headerlink" title="2.2 字符串"></a>2.2 字符串</h3><p>字符串的问题在于字符串的分界符无法作为字符串的内容，比如说在 C 语言中用 <code>"</code> 来表示字符串的开始和终止，那么字符串内容中的 <code>"</code> 就没有办法正常打印，此时就需要用转义字符 <code>\"</code> 来表示一个普通的双引号。</p><p>在 ASSIC 中用普通字符通过转义表达特殊含义的思路，在这里反了过来，在字符串中，<code>"</code> 表示特殊的字符串分界符，而 <code>\"</code> 表示普通的双引号字符。</p><h3 id="2-3-通配符和正则"><a href="#2-3-通配符和正则" class="headerlink" title="2.3 通配符和正则"></a>2.3 通配符和正则</h3><p>这两个是类似的，他们将 <code>* . ? + $ ^ [ ] ( ) { } | \</code> 变成了更具有含义的功能字符，而对于字符串中原本的字符，就需要用转义字符了。</p><h2 id="三、组合"><a href="#三、组合" class="headerlink" title="三、组合"></a>三、组合</h2><p>更让人困惑的是，上面介绍的分类并不是完全不重叠的，事实就是，我们常在编程语言中使用正则表达式，那么转义就会变成多重的，比如说下面的例子</p><pre class="line-numbers language-emacs-lisp" data-language="emacs-lisp"><code class="language-emacs-lisp">"^\\*eshell.*\\*.*$"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个例子中，首先它是一个编程字符串，所以这个字符串内容是</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">^\\*eshell.*\\*.*$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后因为这是一个 ASSIC 字符，所以 <code>\\</code> 表示的是 <code>\</code> ，所以进一步处理得到真正的正则表达式：</p><pre class="line-numbers language-regular-expression" data-language="regular-expression"><code class="language-regular-expression">^\*eshell.*\*.*$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而这种正则中又存在 <code>\*</code> 按照正则的规则，表示的是真正的 <code>*</code> ，所以实际表达是：</p><p>以 <code>*</code> 开头（<code>^\*</code>），紧接 <code>eshell</code> ，而后会匹配任意字符任意长度（<code>.*</code> ），之后紧接 <code>*</code>, 最后以任意字符任意长度结尾（<code>.*$</code>）。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、可打印字符&quot;&gt;&lt;a href=&quot;#一、可打印字符&quot; class=&quot;headerlink&quot; title=&quot;一、可打印字符&quot;&gt;&lt;/a&gt;一、可打印字符&lt;/h2&gt;&lt;p&gt;转义字符的意思是，原本这个字符表达一个意思，而经过转义后，就会表达另一个意思。原本的意思没有什么特别之处（比如说必须是一个普通字符，一个通配符，一个格式控制符），表达出来的另一个意思也同样没有什么特别之处。&lt;/p&gt;
&lt;p&gt;那么为什么要存在转义字符？我们可以用另一个字符来表达更多的意思，而不是让一个已经有一个意思的字符，经过转义后来表达另一个意思。但是可悲的是，这并不是现实的，现实是，我们仅有数量不多的可打印字符，而我们却希望表达更多的意思（这点在正则中尤其明显）。事实就是，每一个可打印字符都有了自己的含义，我们所能做到的，就只是复用他们。&lt;/p&gt;
&lt;p&gt;上面的说法有些绝对，却是有方法可以缓解这种方式，比如用 Java 中数字编码转义字符，如 &lt;code&gt;\uF890&lt;/code&gt; 这种，可以避免复用的尴尬，不过这样又有些不直观，毕竟谁都喜欢写 &lt;code&gt;\n&lt;/code&gt; 而不是 &lt;code&gt;\10&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;二、分类&quot;&gt;&lt;a href=&quot;#二、分类&quot; class=&quot;headerlink&quot; title=&quot;二、分类&quot;&gt;&lt;/a&gt;二、分类&lt;/h2&gt;</summary>
    
    
    
    <category term="语言高阶" scheme="https://thysrael.github.io/categories/%E8%AF%AD%E8%A8%80%E9%AB%98%E9%98%B6/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="语言高阶" scheme="https://thysrael.github.io/tags/%E8%AF%AD%E8%A8%80%E9%AB%98%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成-寄存器保存</title>
    <link href="https://thysrael.github.io/posts/a39a732f/"/>
    <id>https://thysrael.github.io/posts/a39a732f/</id>
    <published>2024-03-13T13:23:05.000Z</published>
    <updated>2024-10-17T06:35:03.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、糟糕的名字"><a href="#一、糟糕的名字" class="headerlink" title="一、糟糕的名字"></a>一、糟糕的名字</h2><p>函数被调用的过程中会使用寄存器，这就可能给函数的调用者造成困扰，原本在调用前的寄存器可能会被调用的函数污染。如果希望寄存器不被污染，可以将寄存器保存在栈上，在调用结束后再将栈上的值重新拷贝回对应的寄存器。</p><p>我们将寄存器分为两组，其中一组由调用者保存，被称为 caller-saved ，这是说调用者可以按照自己的需要来保存这些寄存器，如果自己使用了，那么就保存，如果没有使用，就不需要保存。另一组由被调用者保存，被称为 callee-saved ，被调用者在执行正式的功能前前需要将这些寄存器压栈，在返回前需要将这些寄存器弹栈。</p><p>不过这种标准的定义其实并不容易让人理解其中的原因。我们可以换一个角度去看这件事。当一个函数调用发生时，只有 caller-saved 的寄存器有可能被污染（在 caller 并不保存的情况下），这是因为所有的 callee-saved 寄存器都会本着“谁污染，谁治理”的策略被保护起来。所以 caller-saved register 其实核心特性是 <strong>unsafe</strong> ，也就是“调用前后并能保证寄存器中的值不发生变化”，所以这种寄存器也被称为临时寄存器。而 callee-saved register 则正好相反，是 <strong>safe</strong> 的，调用者不用担心调用一个函数后，自己的寄存器值被改写。</p><p>所以我建议使用更好的名字：</p><ul><li>call-preserved: 不严格对应 callee-saved ，也就是在 call 后寄存器的值不会改变。</li><li>call-clobbered: 不严格对应 caller-saved ，也就是在 call 后寄存器的值可能会发生改变。</li></ul><h2 id="二、解耦的代价"><a href="#二、解耦的代价" class="headerlink" title="二、解耦的代价"></a>二、解耦的代价</h2><p>有没有可能所有寄存器都是 caller-saved 或者都是 callee-saved ？如果所有寄存器都是 caller-saved 的，那么 caller 就要保存自己所有正在使用的寄存器，这种工作是存在冗余的，因为可能有些寄存器 caller 使用了，而 callee 没有使用，如果 caller 一股脑保存，那么就降低了效率。如果所有寄存器都是 callee-saved ，那么 callee 就要保存自己所有使用过的寄存器，这种工作同样存在一定的冗余性，如果 callee 使用了，而 caller 没有使用，那么同样降低了效率。</p><p>如果在全局视角下分析，在调用过程中，我们真正需要保存的寄存器，具有两个特性：</p><ol><li>被 caller 使用且生命周期必须跨越调用过程。</li><li>被 callee 使用。</li></ol><p>那无论是 callee 还是 caller 都没有办法很好达到这个理想状态，因为作为 caller 虽然可以正确的分析出具有第 1 点特性的寄存器，但是对于第 2 点无能为力。同样的 callee 可以清楚地知道第 2 点，但是对于第 1 点一无所知。这种困境是由于“函数”这个概念本就是为了代码段间的解耦和隔离，如果想要一个个解耦的函数，就必须承担无法全局优化的代价。</p><p>如果这样看，那么将寄存器分成差不多大小的两组的行为是有一定道理的，我们虽然不能做到全局优化，但是可以做到基于 caller 和 callee 各自一定的权力，使得双方的关于寄存器使用的“洞见”都可以得到利用。总好过只利用一方的信息。</p><p>从使用上来说，如果寄存器中是一个生命周期很长的变量，那么应当使用 callee-saved register ，它可以保证在其生命周期的多次函数调用中，值始终不发生变化；而如果寄存器中是一个用完就扔的临时变量，那么应当使用 caller-saved-register ，使用它并不需要保存，心理负担小。</p><h2 id="二、特殊寄存器"><a href="#二、特殊寄存器" class="headerlink" title="二、特殊寄存器"></a>二、特殊寄存器</h2><p>没有承载特殊意义的通用寄存器被选为 callee-saved 还是 caller-saved 其实没啥要考虑的，不过有特殊意义的寄存器往往只能是 callee-saved 或者 caller-saved 中的一种。</p><p>参数寄存器只能是 caller-saved 。为了传递参数，caller 必须将参数寄存器中原本的值覆盖成传给 callee 的参数，如果参数寄存器内之前有值，那么就需要 caller 进行保存。这个工作没法由 callee 进行，因为提交给 callee 的参数寄存器已经被污染了。虽然参数寄存器不是 callee 污染的，但是却是在 call 的过程中污染的。</p><p>返回值寄存器只能是 caller-saved 。如果让 callee 保存 caller 的返回值，那么 callee 的自己的返回值该怎么传递给 caller 呢？</p><p>返回地址寄存器只能是 caller-saved 。这是因为 callee 需要使用自己 <code>ra</code> 寄存器，如果 callee 在进入函数时保存了 caller 的 <code>ra</code> ，而退出函数前恢复了 caller 的 <code>ra</code> 那么 <code>return</code> 就会根据 <code>ra</code> 跳转到错误的地方（调到了 caller 被调用的地方了）。</p><p>栈指针寄存器是 callee-saved 。但是其实怎么都说的过去，前面三种是因为设计而不得已，栈指针更像是一种宽松的 call-preserved ，也就是必须在调用前后值不发生变化，至于是 callee-saved 还是 caller-saved 不过是实现需求的手段。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、糟糕的名字&quot;&gt;&lt;a href=&quot;#一、糟糕的名字&quot; class=&quot;headerlink&quot; title=&quot;一、糟糕的名字&quot;&gt;&lt;/a&gt;一、糟糕的名字&lt;/h2&gt;&lt;p&gt;函数被调用的过程中会使用寄存器，这就可能给函数的调用者造成困扰，原本在调用前的寄存器可能会被调用的函数污染。如果希望寄存器不被污染，可以将寄存器保存在栈上，在调用结束后再将栈上的值重新拷贝回对应的寄存器。&lt;/p&gt;
&lt;p&gt;我们将寄存器分为两组，其中一组由调用者保存，被称为 caller-saved ，这是说调用者可以按照自己的需要来保存这些寄存器，如果自己使用了，那么就保存，如果没有使用，就不需要保存。另一组由被调用者保存，被称为 callee-saved ，被调用者在执行正式的功能前前需要将这些寄存器压栈，在返回前需要将这些寄存器弹栈。&lt;/p&gt;
&lt;p&gt;不过这种标准的定义其实并不容易让人理解其中的原因。我们可以换一个角度去看这件事。当一个函数调用发生时，只有 caller-saved 的寄存器有可能被污染（在 caller 并不保存的情况下），这是因为所有的 callee-saved 寄存器都会本着“谁污染，谁治理”的策略被保护起来。所以 caller-saved register 其实核心特性是 &lt;strong&gt;unsafe&lt;/strong&gt; ，也就是“调用前后并能保证寄存器中的值不发生变化”，所以这种寄存器也被称为临时寄存器。而 callee-saved register 则正好相反，是 &lt;strong&gt;safe&lt;/strong&gt; 的，调用者不用担心调用一个函数后，自己的寄存器值被改写。&lt;/p&gt;
&lt;p&gt;所以我建议使用更好的名字：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成" scheme="https://thysrael.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="计算机组成" scheme="https://thysrael.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>硬件平台-主板与外设</title>
    <link href="https://thysrael.github.io/posts/7ee767c0/"/>
    <id>https://thysrael.github.io/posts/7ee767c0/</id>
    <published>2024-03-12T08:04:18.000Z</published>
    <updated>2024-10-17T06:35:03.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、主板"><a href="#一、主板" class="headerlink" title="一、主板"></a>一、主板</h2><p>虽然在《计算机组成》这么课上，我大部分时间都在和 CPU 搏斗，但是并不是说 CPU 就是硬件世界的唯一或者说 Boss，主板上的其他元器件并不是 nobody。非常遗憾我最近才意识到这点。</p><p>一块结构较为完整的主板长成这个样子，可以看到处理 CPU 外，其实上面会有很多个其他的元器件</p><p><img src="/posts/7ee767c0/1280px-Intel_D945GCCR_Socket_775.png" alt="undefined"></p><p>导致结构不完整的一个原因是在 Soc 技术在手机主板上的应用，具有多种功能的元器件，比如说 CPU，内存，各种控制器都会被放到一个芯片里，这样信号不再需要像以前那样通过很多外部的金属线，而是都在芯片里传输，让传输的距离变短。如图所示：</p><p><img src="/posts/7ee767c0/1vVKnGLj6-ttt5vlcmUcdaw.png" alt="img"></p><p>此外因为硬件的发展，许多落后的总线和设备会被淘汰，更加高速的总线和设备会被提出，不过无论如何在主板上的组成成分不会发生变化：</p><ul><li>CPU：计算核心，它是软件开发人员唯一可以控制的东西（但并不意味着它可以控制所有的东西）。</li><li>内存（memory）：暂时存放 CPU 中的运算数据的元件。</li><li>外设（device，I/O，peripheral）：发挥特定作用的设备。</li><li>控制器（controller，adapter）：外设过于复杂，CPU 并不直接控制它们，而是通过控制器间接控制外设</li><li>总线（bus）：连接各个元件的通路，同时也可以看做一个协议，只有遵守协议的双方才可以被连接（车同轨）。</li><li>桥（bridge）：将多个总线连在一起的结构，可能有分发或者汇聚的作用。比起“桥”，它更像是一个“十字路口”。</li></ul><p>这些组成成分里，只有 CPU，内存，外设在软件开发人员眼中不是透明的，而控制器，总线，桥之类的元件是透明的，有失偏颇的说，软件开发者是不会意识到这些东西的存在的。</p><p><img src="/posts/7ee767c0/image-20240312201051842.png" alt="image-20240312201051842"></p><hr><h2 id="二、通信抽象"><a href="#二、通信抽象" class="headerlink" title="二、通信抽象"></a>二、通信抽象</h2><p>既然主板上有如此多的设备，那么 CPU 是怎么和它们通信的？</p><p>对于内存来说，软件开发者有内存空间这个抽象，软件开发者只需要指定要写入或者读出的地址和读取的大小，就可以读写内存了，涉及的指令是 <code>load, store</code> 之类的。此外，我们如果需要配置地址空间，需要修改相关的寄存器，比如说页表基址寄存器或者 TLB 配置寄存器之类的。</p><p>对于设备来说，比较直观的想法是用特殊的指令和寄存器来控制外设。这种方法的缺陷在于“特化”，如果每一个设备都需要对应的指令和寄存器，那么指令集就会爆炸高，而且会过于死板（总不能指望市面上每增加一种新的设备，指令集就修改一遍）。</p><p>所以相比于内存这种有专有指令和寄存器的特例（毕竟只有一种内存，更好的内存都会变成 cache）。CPU 与外设通信的难点在于如何将繁复庞杂的外设都统一出同一个抽象。其实很简单，就是利用“地址空间”这个抽象，“空间”这个概念是“同质”的，“异质”的设备通过占据不同的“空间地址”来表达异质性。我们可以通过写入某个特定的地址来编辑某个特定设备的寄存器的值，也可以通过读出某片空间中的数据来获得某个设备生产出的数据。</p><p>根据地址空间的性质，又有两种方案，一种是独立于内存地址空间，设计一个设备地址空间，所有设备贡献一个地址空间，如下所示：</p><p><img src="/posts/7ee767c0/1094457-20171019112241084-1805450176.png" alt="img"></p><p>内存和 I/O 设备有各自的地址空间。 端口映射 I/O 通常使用一种特殊的 CPU 指令，专门执行 I/O 操作。在 Intel 的微处理器中，使用的指令是 <code>IN</code> 和 <code>OUT</code> 。为了实现地址空间的隔离，要么在 CPU 物理接口上增加一个 I/O 引脚，要么增加一条专用的 I/O 总线。由于 I/O 地址空间与内存地址空间是隔离的，所以有时将 PMIO 称为被隔离的 IO(Isolated I/O)。</p><p>另一种方案是从内存地址空间中取出一部分作为设备地址空间，也就是内存和外设共享同一个地址空间，如下所示：</p><p><img src="/posts/7ee767c0/1094457-20171019111628396-1048214045.png" alt="img"></p><p>在 MMIO 中，内存和 I/O 设备共享同一个地址空间。 MMIO 是应用得最为广泛的一种 IO 方法，它使用相同的地址总线来处理内存和 I/O 设备，I/O 设备的内存和寄存器被映射到与之相关联的地址。当 CPU 访问某个内存地址时，它可能是物理内存，也可以是某个 I/O 设备的内存。因此，用于访问内存的 CPU 指令也可来访问 I/O 设备。每个 I/O 设备监视 CPU 的地址总线，一旦 CPU 访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳 I/O 设备，CPU 必须预留给 I/O 一个地址区域，该地址区域不能给物理内存使用。</p><p>需要强调的是，即使有了 MMIO 和 PMIO 两种手段，有的设备还是需要通过读写 CSR 的方式来进行，比如说 RISCV 和 Arm 对于中断控制器（设备的一种）的配置，这样做的原因可能是会提高读写的速度（不消耗统一的总线带宽）。</p><p>有趣的是，用“地址空间”这样的抽象来概括异质性、多样化的实体的策略在其他地方也有类似体现，比如说 Unix “一切皆文件”的设计抽象，“文件”跟“地址空间”具有一定的相似性。</p><hr><h2 id="三、中断控制器"><a href="#三、中断控制器" class="headerlink" title="三、中断控制器"></a>三、中断控制器</h2><p>上文介绍的是以 CPU 为主导的通信，如果 CPU 想要知道交给外设的某个任务有没有完成，那么 CPU 就必须轮询外设空间里的某个地址（本质可能是某个寄存器），直到收到任务完成的信号，比如说如下代码的核心就是 <code>do while</code> 循环</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * Receive a character */</span><span class="token keyword">char</span> <span class="token function">uart_getc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> r<span class="token punctuation">;</span>    <span class="token comment">/* wait until something is in the buffer */</span>    <span class="token keyword">do</span>    <span class="token punctuation">{</span>        <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"nop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>AUX_MU_LSR <span class="token operator">&amp;</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* read it and return */</span>    r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>AUX_MU_IO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* convert carrige return to newline */</span>    <span class="token comment">// return r == '\r' ? '\n' : r;</span>    <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这种方式非常消耗 CPU 资源，如果当 CPU 发出请求后，CPU 不再忙等而是去干别的事情，等外设完成自己的工作后，再发通知提醒 CPU，这种以外设为主导的方式节省了 CPU 资源。需要强调的是，即使通信的主导方是外设，但是并不意味着控制逻辑是在外设处实现的。外设只是通知 CPU 一下，CPU 依然要进行数据的读取和搬运工作，外设没办法替 CPU 干这种事情（本来也不是 CPU 的活）。</p><p>不过如果以外设为主导，那么依然存在上文讨论的问题，外设众多，如果每个外设的中断都直接给到 CPU，由于外设数量众多，这会导致连接 CPU 引脚数量众多，从而增加 CPU 的体积。如果同时有多个中断发生，CPU 需要维护一个中断等待队列，并且中断还有优先级，维护队列和判定优先级都会占用 CPU 的时间，降低 CPU 的性能。因此中断控制器就应运而生。</p><p>中断控制器相当于一个代理，外设产生的中断会先发给中断控制器，中断控制器管理、控制可屏蔽中断，并且对中断的优先级进行判断，再高优先级中断转交给 CPU，这样 CPU 既能专注计算，又能及时响应到中断事件，并执行相应的中断服务程序。示意图如下（PE 是 process element，即 CPU）。</p><p><img src="/posts/7ee767c0/msi-irq.PNG" alt="消息中断"></p><p>当前主流芯片架构通常采用不同的中断控制器，ARM 使用的 GIC（Generic Interrupt Controller，通用中断控制器）的具体结构如下所示：</p><p><img src="/posts/7ee767c0/gicv3-model.PNG" alt="GICv3编程模型"></p><p>CPU 通过<strong>中断号</strong>来识别不同的外设，中断号是中断控制器对于不同设备的编码（没准就是某个设备连在特定的引脚，它的编号就是那个引脚号）。此外如果设备过多，以至于一个中断控制器</p><p>外设发出通知后，还要经过如下过程才可以到达 CPU</p><p><img src="/posts/7ee767c0/7000.png" alt="img"></p><p>中断控制器只承担了“通知”的功能，而实际的数据搬运，比如说将数据从设备空间搬运到其他地方（这基本上必然发生，因为设备空间的数据很容易被设备的下一次结果覆盖），依然要使用 CPU，这无疑是消耗 CPU 资源的，所以才有了 DMA（<strong>D</strong>irect <strong>M</strong>emory <strong>A</strong>ccess）。如下所示：</p><p><img src="/posts/7ee767c0/system-configuration-with-dmac.png" alt="Direct Memory Access controller and I/O Processor | Computer Architecture"></p><hr><h2 id="四、总线与桥"><a href="#四、总线与桥" class="headerlink" title="四、总线与桥"></a>四、总线与桥</h2><p>总线是一种在计算机内部组件之间或计算机之间传输数据的通信系统。总线给我的直观感觉像是一个马路一样，各种元件的数据都在这个马路上跑。不过实际上，总线更像是一个协议，如果一个设备想要使用某个总线通信，那么就必须实现这个总线对应的协议。</p><p>而桥则是实现了多个总线协议的芯片，它发挥着“中转站”的作用，将不同的数据包分发或者收拢。在历史上有著名的南北桥，这实际是在系统设计上将 I/O 工作层层转包。CPU 把比较慢的 bus 转包给北桥，北桥把更慢的 bus 转包给南桥，南桥把更更慢的 bus 转包给 Super I/O。如下所示：</p><p><img src="/posts/7ee767c0/800px-Motherboard_diagram.svg.png" alt="undefined"></p><h2 id="五、设备树"><a href="#五、设备树" class="headerlink" title="五、设备树"></a>五、设备树</h2><h3 id="5-1-意义"><a href="#5-1-意义" class="headerlink" title="5.1 意义"></a>5.1 意义</h3><p>设备树提出的背景是在Linux3.x之前的内核源码中，存在大量对板级细节信息描述的代码。这些代码充斥在 <code>/arch/arm/plat-xxx</code>和 <code>/arch/arm/mach-xxx</code> 目录中。每年新出的 ARM 架构芯片少说都有数十、数百款，每一款芯片又会有很多款基于该芯片的板子，这些板子上的设备又不相同，每一块板子都要有自己的板级信息文件，所以 Linux 内核下板级信息文件将会成指数级增长！关键是这些板级信息文件还都是 <code>.c</code>  或 <code>.h</code> 文件，它们都会被编译进 Linux 内核中，导致 Linux 内核“虚胖”。</p><p>所以将描述主板上外设信息的工作从 Linux Kernel 中去除，采用设备树的方式描述主板信息，内核只需要读取设备树文件并根据文件选择适合自己的驱动就可以了（似乎应用了 kenerl module 的技术）。之所以称之为“设备树”，是因为用采用树形结构描述板级设备，如下所示：</p><p><img src="/posts/7ee767c0/8f7debc826664d2c8092f8ff7a0061cf.png" alt="img"></p><p>虽然设备树是用于解决驱动的问题，但是我们也可以通过设备树来了解一些主板的信息。</p><h3 id="5-2-文件"><a href="#5-2-文件" class="headerlink" title="5.2 文件"></a>5.2 文件</h3><p>DTB（device tree source）文件是一种 ASCII 文本格式的设备树描述文件，此文件适合人类阅读主要是给用户看的。一个 <code>.dts</code> 文件对应一个 ARM 的设备，一般放置在 <code>arch/xxx/boot/dts/</code> 中。由于 DTS 中包含了很多公共部分，linux 内核为了简化，将 Soc 公共部分提炼为 <code>.dtsi</code> 文件，类似 c 语言中的 <code>.h</code> 文件。</p><p>DTB（device tree blob） 是将 DTS 编译以后得到的二进制文件。将 DTS 编译为 DTB 需要编译工具 DTC（device tree compiler）。</p><p>内核设备树绑定文档（kernel device tree binding documents）在 <code>Documentation/devicetree/bindings/</code> 下按照硬件和子系统的分类进行组织。提供的文档以 <code>.txt</code> 或 <code>.yaml</code> 的格式。所谓的“设备绑定”指的是“硬件和驱动建立联系”的过程，也就是根据主板上的设备选择对应的驱动的过程。</p><h3 id="5-3-节点格式"><a href="#5-3-节点格式" class="headerlink" title="5.3 节点格式"></a>5.3 节点格式</h3><p>device tree node 的格式如下，我们分几个部分进行介绍：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">[</span>label<span class="token operator">:</span><span class="token punctuation">]</span> node<span class="token operator">-</span>name<span class="token punctuation">[</span>@unit<span class="token operator">-</span>address<span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token punctuation">[</span>properties definitions<span class="token punctuation">]</span>    <span class="token punctuation">[</span>child nodes<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先介绍第一行的部分，这个部分主要标识 node 的身份，比如说</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">intc<span class="token operator">:</span> interrupt<span class="token operator">-</span>controller@<span class="token number">00</span>a01000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>interrupt-controller</code> 说明这是一个中断控制器设备，而 <code>@00a01000</code> 则说明这个设备 MMIO 后的首地址是 <code>0x00a01000</code> 。前面的 <code>intc</code> 是标签，方便“访问节点”，我也不确定什么是访问节点，不过以上面的举例，我们可以用如下语法来声明某个设备是该中断控制器的子节点（使用 <code>&amp;intc</code>）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">interrupt<span class="token operator">-</span>parent <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&amp;</span>intc<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-4-属性"><a href="#5-4-属性" class="headerlink" title="5.4 属性"></a>5.4 属性</h3><p><code>properties</code> 指的是设备的属性，其呈现形式是一个 <code>key-value</code> 组。<code>value</code> 具有多种数据类型，每种数据类型都具有一定的格式，也可以为空，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// string</span>compatible <span class="token operator">=</span> <span class="token string">"arm,cortex-a7"</span><span class="token punctuation">;</span>compatible <span class="token operator">=</span> <span class="token string">"fsl,imx6ull-gpmi-nand"</span><span class="token punctuation">,</span> <span class="token string">"fsl, imx6ul-gpmi-nand"</span><span class="token punctuation">;</span><span class="token comment">// cell(unsigned int32 array)</span>reg <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>reg <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token number">0</span> <span class="token number">0x123456</span> <span class="token number">100</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token comment">// bytestring(unsigned char)</span>local<span class="token operator">-</span>mac<span class="token operator">-</span>address <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">00</span> <span class="token number">00</span> <span class="token number">12</span> <span class="token number">34</span> <span class="token number">56</span> <span class="token number">78</span><span class="token punctuation">]</span><span class="token punctuation">;</span>local<span class="token operator">-</span>mac<span class="token operator">-</span>address <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">000012345678</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// null</span>tlb<span class="token operator">-</span>split<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>存在一些比较经典的属性：</p><p><strong>compatible</strong></p><p>compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！compatible 属性的值是一个字符串列表，compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序，compatible 属性的值格式如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"manufacturer,model"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举个例子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">compatible <span class="token operator">=</span> <span class="token string">"fsl,imx6ul-evk-wm8960"</span><span class="token punctuation">,</span><span class="token string">"fsl,imx-audio-wm8960"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>fsl</code> 表示厂商是飞思卡尔，<code>imx6ul-evk-wm8960</code> 和 <code>imx-audio-wm8960</code> 表示驱动模块名字。这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。</p><p><strong>reg</strong></p><p>用于描述设备的地址空间特性，一般呈现这种形式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">reg <span class="token operator">=</span> <span class="token operator">&lt;</span>address1 length1 address2 length2 address3 length3 …… <span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样一片地址空间就可以被一个首地址和一个空间长度所描述。但是遗憾的是，因为数据类型 cell 的本质是 <code>u32</code>，所以当遇到 64 位地址的情况，那么就需要两个 cell 去描述同一个地址或者长度，比如说如下所示</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">reg <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token number">0x0</span> <span class="token number">0xc000000</span> <span class="token number">0x0</span> <span class="token number">0x4000000</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>地址是 <code>0x00000000c000000</code> 长度是 <code>0x0000000004000000</code> 。但是这种方法产生了歧义，比如如果按照 32 位地址空间去解释，那么这个描述的就是两段空间，第一段空间的首地址是 <code>0x0</code>，长度是 <code>0xc000000</code>，第二段地址空间的首地址是 <code>0x0</code>，长度是 <code>0x4000000</code>。那么如何区分这两种情况呢，我们又引入了两个属性。</p><p><strong>#address-cells, #size-cells</strong></p><p><code>#address-cells</code> 属性值决定了子节点 <code>reg</code> 属性中地址信息所占用的字长，<code>#size-cells</code> 属性值决定了子节点 reg 属性中长度信息所占的字长。举个例子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">address</span><span class="token expression"><span class="token operator">-</span>cells <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">&gt;</span><span class="token punctuation">;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">size</span><span class="token expression"><span class="token operator">-</span>cells <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token punctuation">;</span></span></span>reg <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token number">0x0</span> <span class="token number">0xc000000</span> <span class="token number">0x4000000</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为 <code>#address-cells</code> 是 <code>&lt;2&gt;</code>，所以前两个 cell <code>0x0 0xc000000</code> 是地址，而 <code>#size-cells</code> 是 <code>&lt;1&gt;</code>，所以只需要一个 cell <code>0x4000000</code> 描述长度。</p><p><strong>status</strong></p><p>status 属性是和设备状态有关的，status 属性值也是字符串，如下表所示：</p><div class="table-container"><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>“okay”</td><td>表示设备可用且正常工作。</td></tr><tr><td>“disabled”</td><td>表示设备已被禁用或不可用。</td></tr><tr><td>“fail”</td><td>表示设备启动或初始化失败。</td></tr><tr><td>“unsupported”</td><td>表示设备不被支持。</td></tr></tbody></table></div><p><strong>model</strong></p><p>model 属性值也是一个字符串，一般 model 属性描述设备模块信息，比如名字什么的，比如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">model <span class="token operator">=</span> <span class="token string">"wm8960-audio"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>interrupts</strong></p><p>这是一组属性：</p><ul><li><code>interrupt-controller</code> 一个空属性用来声明这个 node 接收中断信号，即这个 node 是一个中断控制器。</li><li><code>#interrupt-cells</code> 是中断控制器节点的属性，用来标识这个控制器需要几个单位做中断描述符，用来描述子节点中 <code>interrupts</code> 属性使用了父节点中的 <code>interrupts</code> 属性的具体的哪个值。一般，如果父节点的该属性的值是 <code>&lt;3&gt;</code>，则子节点的 <code>interrupts</code> 的格式为 <code>&lt;中断域 中断 触发方式&gt;</code> ，如果父节点的该属性是 <code>&lt;2&gt;</code>，则是 <code>&lt;中断 触发方式&gt;</code> 。</li><li><code>interrupt-parent</code> 标识此设备节点属于哪一个中断控制器，如果没有设置这个属性，会自动依附父节点的。</li><li><code>interrupts</code> 一个中断标识符列表，表示每一个中断输出信号的具体信息。</li></ul><h3 id="5-5-特殊节点"><a href="#5-5-特殊节点" class="headerlink" title="5.5 特殊节点"></a>5.5 特殊节点</h3><p><strong>root</strong></p><p>每一个 dts 文件都有一个 root 根节点，内核通过 <code>/</code> 找到设备。</p><p><strong>aliases</strong></p><p>单词 aliases 的意思是“别名”，因此 aliases 节点的主要功能就是定义别名，定义别名的目的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过 <code>&amp;label</code> 来访问节点，这样也很方便。</p><p><strong>chosen</strong></p><p>chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。一般 DTS 文件中 chosen 节点通常为空或者内容很少。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、主板&quot;&gt;&lt;a href=&quot;#一、主板&quot; class=&quot;headerlink&quot; title=&quot;一、主板&quot;&gt;&lt;/a&gt;一、主板&lt;/h2&gt;&lt;p&gt;虽然在《计算机组成》这么课上，我大部分时间都在和 CPU 搏斗，但是并不是说 CPU 就是硬件世界的唯一或者说 Boss，主板上的其他元器件并不是 nobody。非常遗憾我最近才意识到这点。&lt;/p&gt;
&lt;p&gt;一块结构较为完整的主板长成这个样子，可以看到处理 CPU 外，其实上面会有很多个其他的元器件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/7ee767c0/1280px-Intel_D945GCCR_Socket_775.png&quot; alt=&quot;undefined&quot;&gt;&lt;/p&gt;
&lt;p&gt;导致结构不完整的一个原因是在 Soc 技术在手机主板上的应用，具有多种功能的元器件，比如说 CPU，内存，各种控制器都会被放到一个芯片里，这样信号不再需要像以前那样通过很多外部的金属线，而是都在芯片里传输，让传输的距离变短。如图所示：&lt;/p&gt;</summary>
    
    
    
    <category term="硬件平台" scheme="https://thysrael.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="S8课上" scheme="https://thysrael.github.io/tags/S8%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="硬件平台" scheme="https://thysrael.github.io/tags/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>硬件平台-ARM条件码</title>
    <link href="https://thysrael.github.io/posts/1be60a6e/"/>
    <id>https://thysrael.github.io/posts/1be60a6e/</id>
    <published>2024-02-11T14:42:53.000Z</published>
    <updated>2024-10-17T06:35:03.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><p>在 Armv8 的 A32 架构或者 Armv7 及以前的指令集中，每条指令都可以“条件执行”，也就是根据 CPSR 的条件码来确定这条指令是否真的具有执行效果。</p><p>比如说如下指令，只有在 CPSR 中 <code>Z</code> 位为 1 的时候，<code>addz</code> 这条指令才有实际效果，这依赖于前一条指令 <code>cmp</code> 对 CPSR 的修改（ARM 同样可以指定是否修改 CPSR，这是通过在指令位中的 <code>S</code> 确定的）。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">cmp r4, r5addz r1, r2, r3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MIPS 或者 RISCV 都有条件指令，不过这些条件指令一般是条件指令，这样可以实现编程思想中的分支结构。Arm 的特殊之处在于每条 32 位指令的高 4 位都是条件码，这就会导致每条指令都是条件指令。</p><p><img src="/posts/1be60a6e/150003_5d64c652d9-屏幕截图-2022-05-22-165758.jpg" alt="屏幕截图 2022-05-22 165758.jpg"></p><p>条件指令编码如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">条件码  Cond</th><th style="text-align:left">条件助记符</th><th style="text-align:left">CPSR 中条件标志位 cpsr_f 的值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0000</td><td style="text-align:left">EQ</td><td style="text-align:left">Z=1</td><td style="text-align:left">相等</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0001</td><td style="text-align:left">NE</td><td style="text-align:left">Z=0</td><td style="text-align:left">不相等</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">0010</td><td style="text-align:left">CS HS</td><td style="text-align:left">C=1</td><td style="text-align:left">无符号数大于或等于</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">0011</td><td style="text-align:left">CC LO</td><td style="text-align:left">C=0</td><td style="text-align:left">无符号数小于</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">0100</td><td style="text-align:left">MI</td><td style="text-align:left">N=1</td><td style="text-align:left">负数</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">0101</td><td style="text-align:left">PL</td><td style="text-align:left">N=0</td><td style="text-align:left">正数或零</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">0110</td><td style="text-align:left">VS</td><td style="text-align:left">V=1</td><td style="text-align:left">溢出</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">0111</td><td style="text-align:left">VC</td><td style="text-align:left">V=0</td><td style="text-align:left">未溢出</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">1000</td><td style="text-align:left">HI</td><td style="text-align:left">C=1,Z=0</td><td style="text-align:left">无符号数大于</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">1001</td><td style="text-align:left">LS</td><td style="text-align:left">C=0,Z=1</td><td style="text-align:left">无符号数小于或等于</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">1010</td><td style="text-align:left">GE</td><td style="text-align:left">N=V</td><td style="text-align:left">带符号数大于或等于</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">1011</td><td style="text-align:left">LT</td><td style="text-align:left">N!=V</td><td style="text-align:left">带符号数小于</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">1100</td><td style="text-align:left">GT</td><td style="text-align:left">Z=0,N=V</td><td style="text-align:left">带符号数大于</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">1101</td><td style="text-align:left">LE</td><td style="text-align:left">Z=1,N!=V</td><td style="text-align:left">带符号数小于或等于</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">1110</td><td style="text-align:left">AL</td><td style="text-align:left">任何</td><td style="text-align:left">忽略条件，即无条件执行</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">1111</td><td style="text-align:left"></td><td style="text-align:left">任何</td><td style="text-align:left">系统保留</td></tr></tbody></table></div><p>ARM 中这种独特的设计之前让我感觉非常奇怪，因为要消耗足足 4 位来进行条件编码，同时“指令有可能执行不成功”的概念非常困扰我，这让我觉得这是一种 CPU 资源的浪费，因为在运行无效指令的时候 CPU 在“空转”。</p><p>当所有的指令都是条件指令的时候，那么分支结构的汇编实现就多了一种方法，举个例子，我们常用的 C 语言分支结构为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// if-statement</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">// else-statement</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是普通汇编翻译（伪汇编，表意），那么是下面的样子，先利用一个 <code>cmp</code> 指令比较 <code>a, b</code> ，然后利用 <code>bne</code> 这个条件跳转指令来决定分支流向，如果不发生跳转，那么就会执行 <code>if1, if2, ...</code> ，而如果发生跳转，则会执行 <code>else1, else2, ...</code> 。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">cmp r, a, bbne r, l1if1if2...b l2l1:else1else2...l2:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ARM 可以有另一种翻译方法，如下所示，同样利用 <code>cmp</code> 指令完成比较，但是不再有 <code>bne, b</code> 这样的跳转指令来构成分支流了，而是 <code>if1z, if2z, ..., else1nz, else2nz, ...</code> 这些指令均会被送给 CPU，但是只有一些指令会发挥实际作用，这依赖于 <code>cmp</code> 的结果。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">cmp a, bif1zif2z...else1nzelse2nz...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>arm 在提出这种翻译方式时，是希望编译器的开发者可以在一些部分采用第二种模式。</p><hr><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="2-1-指令条数"><a href="#2-1-指令条数" class="headerlink" title="2.1 指令条数"></a>2.1 指令条数</h3><p>乍一看第二种模式并不好，这是因为如果 <code>if-statement</code> 和 <code>else-statement</code> 都各翻译出 5 条汇编，那么第一种模式总共执行的指令数是 7 或者 8 条，而第二种模式则会翻译出 11 条指令，代价要远远高于第一种。</p><p>不过如果 <code>if-statement</code> 和 <code>else-statement</code> 各翻译出 2 条汇编，那么第一种模式是 4 或 5 条，而第二种是 5 条，差距并没有这么大。也就是说，第二种模式更适用于 C 语言中的 <code>?</code> 三目运算符这种类似的<strong>短小的分支结构</strong>。</p><h3 id="2-2-流水线层数"><a href="#2-2-流水线层数" class="headerlink" title="2.2 流水线层数"></a>2.2 流水线层数</h3><p>指令条数的优势并不明显，但是对于流水线来说非常有用，这是因为按照第一种模式，要等到 <code>r</code> 被计算出来才可以确定分支的流向，同时 <code>bne</code> 指令拿到 <code>r</code> 的时间也会后延，跳转指令后的指令如果不采用延迟槽技术，那么许多已经进入流水线的指令都会被注销，也就是说，虽然在简单的顺序模型下，第一种模式下的 CPU 不会执行“冗余”的指令，但是在流水线 CPU 中，依然是有可能执行</p><p>而第二种模式，CPSR 的值可以比通用寄存器 <code>r</code> 更容易拿到，因为 CPSR 的约束更多，所以转发处理要更加简洁，CPU 可以更早知道比较的结果，那么就不会造成过多指令的浪费。而且减少分支更加方便 CPU 进行调度。</p><p>换句话说，深流水水级的设计对于分支指令天然不友好，流线线长度越长，获得分支结果的时间就越长，而在分支结果出来之前，CPU 只能等待。解决这个问题有两种方式，一种是采用更加强大的分支预测单元，这样在 CPU 等待结果的时候先处理猜测的分支上的指令。另一种就是 arm 条件码的设计，将分支结果在靠前的流水线就计算出来，这样避免了过多的等待，而且在形式上消除了分支结构，降低了处理器的设计难度。</p><h3 id="2-3-发射宽度"><a href="#2-3-发射宽度" class="headerlink" title="2.3 发射宽度"></a>2.3 发射宽度</h3><p>不过第二种模式并非非常适合流水线，比如说当 CPU 发射较为宽的时候（多发射乱序），条件码相当于指令会读写 CPSR 这个特殊的寄存器，那么就会导致指令间的依赖关系增加，进而增加串行化程度，也就是会导致第一种模式比第二种要更加占优势。</p><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>ARM 的条件码设计更加类似于 CISC 的设计思想，相比于 RISC 要更为复杂，复杂的指令不利于提高并行性，但是复杂的指令可以减少指令数，分支数。虽然这些优点对于多发射 CPU 并没有那么显著的改观，甚至是负优化。但是应当意识到，并不是所有的 CPU 的目的都是为了运算的极致高效，分支预测和多发射都是十分消耗硬件资源和能耗的设计，在 ARM 大展身手的嵌入式领域，条件码可以显著提高效率，并不是没有荒诞的设计。</p><p>不过随着硬件水平的提高，条件码似乎也在退出历史舞台，比如说 ARM 自家的 A64 指令集或者 RISCV 这种年轻的指令集都没有采用条件码设计。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h2&gt;&lt;p&gt;在 Armv8 的 A32 架构或者 Armv7 及以前的指令集中，每条指令都可以“条件执行”，也就是根据 CPSR 的条件码来确定这条指令是否真的具有执行效果。&lt;/p&gt;
&lt;p&gt;比如说如下指令，只有在 CPSR 中 &lt;code&gt;Z&lt;/code&gt; 位为 1 的时候，&lt;code&gt;addz&lt;/code&gt; 这条指令才有实际效果，这依赖于前一条指令 &lt;code&gt;cmp&lt;/code&gt; 对 CPSR 的修改（ARM 同样可以指定是否修改 CPSR，这是通过在指令位中的 &lt;code&gt;S&lt;/code&gt; 确定的）。&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-asm&quot; data-language=&quot;asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;cmp r4, r5
addz r1, r2, r3&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MIPS 或者 RISCV 都有条件指令，不过这些条件指令一般是条件指令，这样可以实现编程思想中的分支结构。Arm 的特殊之处在于每条 32 位指令的高 4 位都是条件码，这就会导致每条指令都是条件指令。&lt;/p&gt;</summary>
    
    
    
    <category term="硬件平台" scheme="https://thysrael.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
    
    <category term="直观理解" scheme="https://thysrael.github.io/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/"/>
    
    <category term="S7课上" scheme="https://thysrael.github.io/tags/S7%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="硬件平台" scheme="https://thysrael.github.io/tags/%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>吃喝玩乐-字体演变</title>
    <link href="https://thysrael.github.io/posts/f0b58a03/"/>
    <id>https://thysrael.github.io/posts/f0b58a03/</id>
    <published>2024-02-11T13:34:57.000Z</published>
    <updated>2024-10-17T06:35:02.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字体介绍"><a href="#一、字体介绍" class="headerlink" title="一、字体介绍"></a>一、字体介绍</h2><h3 id="1-1-演变历史"><a href="#1-1-演变历史" class="headerlink" title="1.1 演变历史"></a>1.1 演变历史</h3><ul><li>最早的字体是“帝国大写体”（Imperial Capitals），也被称为“罗马大写体”，古罗马时期字体，用于在石碑上记录重大事件。</li><li>然后是“卡洛林小写体”（Carolingian Minuscule），这种字体在中世纪早期出现，这种字体字间距大，结构清晰简单，但是已经具有了一定的宗教色彩。</li><li>中世纪后期西欧出现了“哥特体”（Gothic），是卡洛林小写体的演化体，这种字体更加复杂和华丽，字间距小，笔画厚重而末端尖锐，具有强烈的宗教色彩。</li><li>“人文主义体”是“文艺复兴之父”彼特拉克提倡发明的字体，受启发于卡洛林小写体字间距大，方便阅读的特点，是文艺复兴早期的字体，风格比较圆润轻松，字轴比较倾斜。</li><li>“意大利斜体”受启发于“人文主义体”，这种字体更加自由畅快，同时由于斜体的特点，可以兼顾辨认和节省空间的特点，是当时印刷业的新宠。</li><li>“印刷罗马体”是活字印刷术发明后在意大利发明的，这种字体受启发于“人文主义体”和“帝国大写体”，这种字体字轴中正，笔画圆润，书写痕迹浅，成为了“人文主义体”的淘汰者。</li></ul><p><img src="/posts/f0b58a03/image-20240211214139291.png" alt="image-20240211214139291"></p><h3 id="1-2-具体介绍"><a href="#1-2-具体介绍" class="headerlink" title="1.2 具体介绍"></a>1.2 具体介绍</h3><p>介绍的这三种字体是“三种主流字体”，也被称为“标准体”。</p><h4 id="1-2-1-哥特体"><a href="#1-2-1-哥特体" class="headerlink" title="1.2.1 哥特体"></a>1.2.1 哥特体</h4><p>“哥特体”来自于曾于公元 3~5 世纪侵略意大利并瓦解罗马帝国的德国哥特族人，这种字体在继承了卡洛林小写体的基础上在中世纪成为了教会专用的字体。</p><p><img src="/posts/f0b58a03/1-1-2.jpg" alt=""></p><p>因为这种字体极其规整和华丽，具有相当繁复的排版和注意事项，所以需要培养专业的抄写员来使用这种字体，书写难度极大；而因为这种字体笔划十分厚重，字间距和行间距都十分逼仄，所以阅读难度也是极大的。</p><p><img src="/posts/f0b58a03/1-2-1.gif" alt=""></p><h4 id="1-2-2-印刷罗马体"><a href="#1-2-2-印刷罗马体" class="headerlink" title="1.2.2 印刷罗马体"></a>1.2.2 印刷罗马体</h4><p>德国人古登堡发明了现代印刷术，他工厂的工人将这种技术传到了意大利，为了迎合人文主义者的偏好，他们在人文主义体的基础上创造了“前印刷罗马体”，斯皮拉兄弟从“罗马大写体”吸收了衬线，大写字体，字符断写等多种特色，创造出了“印刷罗马体”。</p><p><img src="/posts/f0b58a03/1-2-2.png" alt=""></p><p>印刷罗马体的最为显著特点是“直立，正写”。这本是碑文字体的特征，恰巧满足了印刷的需求，同时还使得字体变得大气和规整，阅读变得轻松。此外，印刷罗马体的字形支持更全，支持大小写字母、数字和多种特殊符号标点。</p><h4 id="1-2-3-意大利斜体"><a href="#1-2-3-意大利斜体" class="headerlink" title="1.2.3 意大利斜体"></a>1.2.3 意大利斜体</h4><p>“文艺复兴之父”彼特拉克借鉴了卡洛林小写体清晰易辨的特点，创造了用于自己平常书写的手写体，这种字体后来发展成了“人文主义草体”，当其传入意大利后，被固化成了一种印刷字体。</p><p><img src="/posts/f0b58a03/1-1-5.png" alt=""></p><p>意大利斜体与“手写”密不可分，它“斜体”，“轻快”，“飘逸”的特点正是从手写字体中汲取的，同时也给人在阅读时一种“亲切感”。此外，手写体非等宽的特征也使得在同一行可以容纳更多的字符，对于印刷更为经济。</p><h3 id="1-3-对比总结"><a href="#1-3-对比总结" class="headerlink" title="1.3 对比总结"></a>1.3 对比总结</h3><h4 id="1-3-1-设计"><a href="#1-3-1-设计" class="headerlink" title="1.3.1 设计"></a>1.3.1 设计</h4><p>需要强调这些方面是直观朴素的，因为字体设计的专业名词是十分繁复，不利于科普的：</p><div class="table-container"><table><thead><tr><th style="text-align:center">字体</th><th style="text-align:center">风格</th><th style="text-align:center">结构</th><th style="text-align:center">排版</th></tr></thead><tbody><tr><td style="text-align:center">哥特体</td><td style="text-align:center">繁复，宗教性强</td><td style="text-align:center">笔划厚重而末端尖锐</td><td style="text-align:center">字间距小，行间距小，双栏排版</td></tr><tr><td style="text-align:center">印刷罗马体</td><td style="text-align:center">大气，厚重</td><td style="text-align:center">衬线，正写</td><td style="text-align:center">字间距大，行间距大，单栏排版</td></tr><tr><td style="text-align:center">意大利斜体</td><td style="text-align:center">飘逸，手写</td><td style="text-align:center">斜体</td><td style="text-align:center">字间距小，行间距大，单栏排版</td></tr></tbody></table></div><h4 id="1-3-2-经济基础"><a href="#1-3-2-经济基础" class="headerlink" title="1.3.2 经济基础"></a>1.3.2 经济基础</h4><p>正如文艺复兴中发生的其他变革一样，字体演变也与文艺复兴时期发生的科学和技术进步有关。</p><p>在中世纪，纸张使用的是羊皮纸，这种材料极为昂贵，为降低书写材料的费用，哥特体压缩字间距和行间距，在同样的篇幅下容纳更多的字而产生的字体。同时因为没有印刷术，所以只能将“抄写员”作为一个专业的职业去培养，这也是极其花销大的事情。</p><p><img src="/posts/f0b58a03/1-3-5.jpg" alt=""></p><p>正是因为材料和抄写的昂贵，所以使得书本变得极为昂贵，这种昂贵又呈现了某种“待价而沽”的卖方市场特征，在羊皮纸的选择上要求更加稀有的品种，在抄写员的培养上也带有了某种宗教仪式色彩。这无疑形成了恶性循环，最终导致的结果就是字体的设计权被宗教垄断。</p><p>造纸术由阿拉伯传入欧洲，相比于原先的羊皮纸方案，成本低廉，材料广泛，降低了知识传播的成本，被生产资料垄断的教育资格有了流向普罗大众的可能。德国人古登堡发明了现代印刷术，由三个部分组成：铅活字印刷，印刷油墨，印刷机。这项技术加速了文字流通的速度，促进了文字传播的需求。</p><p><img src="/posts/f0b58a03/1-3-11.jpeg" alt=""></p><p>这些新兴技术首先在技术上要求字体做出变革，因为原有哥特体字间距狭窄，末端尖锐的特点与活字印刷术并不匹配，反而适用于碑文的罗马体与铅活字更为类似。而另一个方面，由于成本降低，打破了教会对于文字的垄断，字体成为了许多平民的常客，更加亲民，接地气的字体设计成为时兴的思想。</p><h4 id="1-3-3-思想"><a href="#1-3-3-思想" class="headerlink" title="1.3.3 思想"></a>1.3.3 思想</h4><p>在思想层面，“哥特体”不止形式繁缛，在内涵上也有很强的宗教色彩。“将每一次落笔，都视为对于魔鬼的回击”淋漓尽致的表现了这一点。这种思想性质使得哥特体很难承载一些表达人本主义倾向的文字，用哥特体记录日常生活就像穿西装吃沙县小吃一样。不过需要强调，哥特体并没有在历史中湮没，它成为了一种表示“郑重权威”的字体，常用于设计报社的 logo 。</p><p><img src="/posts/f0b58a03/1-3-11.png" alt=""></p><p>印刷罗马体效仿帝国大写体，其设计思想是与文艺复兴提倡的“对希腊和古罗马的黄金年代的复现”一致，甚至本就在这种复古精神的指引下开创了这种字体。另外这种字体的贡献者多为印刷厂工人，所以他们对于规格化，全面化，普适化的工业审美也注入到了这款字体里。</p><p>意大利斜体起源于手写字体，发明的初衷是为了创造一种更加适合快速书写和阅读的字体，这种需求是文艺复兴人文主义的一种反映。写字”的权利得到下放，在此诉求上诞生的“意大利斜体”要更加舒展和自由，适合快速的书写。另外，大部分手写体都有轻便简洁的诉求，但是意大利斜体之所以著名，与其被印刷商人设计成固定的字体有一定的关系。</p><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="2-1-解放"><a href="#2-1-解放" class="headerlink" title="2.1 解放"></a>2.1 解放</h3><p><strong>字体是文字的实现，文字是思想的镜像。</strong>文艺复兴运动是一场思想解放运动。“解放”指的是摆脱限制自身的枷锁，文艺复兴是一场让人们摆脱思想上宗教上的禁欲主义枷锁，回归人本的运动。</p><p>中世纪采用繁复的字体可以看做是一种对于文字这种稀缺资源的垄断和对于思想的准入壁垒。当社会生产力发展到了不适应封建社会的生产方式时，字体这个看似十分形式化和鸡肋的小东西，也可以发挥“朗基努斯之枪”的作用，成为了从宗教下解放人性的利器。</p><h3 id="2-2-繁城之下"><a href="#2-2-繁城之下" class="headerlink" title="2.2 繁城之下"></a>2.2 繁城之下</h3><blockquote><p>我很想在历史找到一个“反派”，但是很多时候我只能够竭尽全力地去认识某一坐标下的“过去”和“未来”。</p></blockquote><p>需要强调的是，哥特式并不是完全的落后的宗教字体，即哥特式并非一种固定的形态，而是表现出一种状态，一种过程，是历经中世纪漫长思想禁锢过程后人们开始对世界重拾思考的迹象，可能体现了一种“虽然真理永不可得，但仍旧要追求不息”的精神。这点在哥特体的多种变体中有所体现，有些字体已经呈现了简化趋势。</p><p>此外，新兴的“印刷罗马体”和“意大利斜体”并不是平地起高楼，他们的诞生同样吸收了哥特体或者卡洛林小写体这些中世纪字体的长处。</p><p>此外，虽然随着造纸术和活字印刷术的出现，大大降低了文字的使用成本，打破了教会对于文字的垄断，但是印刷术将字体设计推上了更加崇高的位置，一款好的字体可以低成本地占据平民生活的每个角落，相似风格的字体往往只有一个字体幸存下来。在那时字模和活字的制作都是要耗费大量的时间和成本的，任何一套字模和活字都是一份实实在在的不小的资产，人们不能因为不喜欢某种字母形式随意地抛弃它和替换到另一种。字体重新被垄断，这次不是教会，而是商人。</p><h2 id="三、现代启示：中文字体"><a href="#三、现代启示：中文字体" class="headerlink" title="三、现代启示：中文字体"></a>三、现代启示：中文字体</h2><h3 id="3-1-稀缺性"><a href="#3-1-稀缺性" class="headerlink" title="3.1 稀缺性"></a>3.1 稀缺性</h3><p>电子中文字体，无论是商用还是开源，都是极其稀少的。这是多种原因造成的：</p><ul><li>中文字体不像英文字体一样只有不到 100 个字符，中文有七万左右的字符，涉及繁体、简体、生僻字、标点等类别，设计的工作量极大。</li><li>英文字体的设计可以和数学曲线联系起来，而中文字体因为独特的书法美感，无法用数学表达式简单概括。</li><li>字体设计追求多个字符之间的统一感，对于有着七万多字符，并且每个字差距极大的中文而言，这是极其困难的事情。</li><li>现有的中国书法理论的建立是基于手写体的，所以设计的理论积累并不高，很多时候只能借鉴日本的成熟字体设计方案和思路。</li></ul><p>中文字体的稀缺性使得其具有很高的商业价值，常见的中文字体均为微软等巨头企业开发的商业字体，这些字体有可能对于普通用户免费，但是对于海报设计，网站开发等商业行为往往收取高额的版权费用，这无疑是一种商业垄断行为。此外商用字体禁止使用者自行修改，因为修改字形导致的商业纠纷屡见不鲜。</p><p><img src="/posts/f0b58a03/3-1-3.png" alt=""></p><h3 id="3-2-重要性"><a href="#3-2-重要性" class="headerlink" title="3.2 重要性"></a>3.2 重要性</h3><p>无论时代如何发展，思想的表达总要落实到文字上，而文字总是要借助字体来呈现。字体依然是思想的“最后一道关隘”，“字体资源”依然是重要资源。</p><p>对于中文字体而言，不同于英文字体，多个字符编码一个单词的设计，中文的每个字都表达了一定的含义，禁掉任何一个字不仅会导致意思的表达出现障碍，甚至会导致文字本身承载的意思在文化中丢失。</p><p>同时对于任何一种字体，不断地更新迭代是其发展维持活力的最重要因素。电子字体同样也当具有演变的能力，文字的演变本身反映着思想的演变，而演变的权利应当归属于每一个文字的使用者。</p><p><img src="/posts/f0b58a03/image-20240211214718761-17076592401651.png" alt="image-20240211214718761"></p><h3 id="3-3-中文开源字体"><a href="#3-3-中文开源字体" class="headerlink" title="3.3 中文开源字体"></a>3.3 中文开源字体</h3><p>针对上文对于中文字体的现状分析，我们认为中文开源字体或许是改善现状的一个方案：</p><ul><li>开源避免了复杂的版权纠纷，使得用户使用字体变得更加轻松。</li><li>开源字体依赖社区协作，使得用户的意见变得更加重要。每个用户都可以方便地修改字体。</li><li>开源字体避免了商业寡头的垄断行为。</li><li>开源的本质同样是解放生产力。</li></ul><p><img src="/posts/f0b58a03/image-20240211214739084-17076592605642.png" alt="image-20240211214739084"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、字体介绍&quot;&gt;&lt;a href=&quot;#一、字体介绍&quot; class=&quot;headerlink&quot; title=&quot;一、字体介绍&quot;&gt;&lt;/a&gt;一、字体介绍&lt;/h2&gt;&lt;h3 id=&quot;1-1-演变历史&quot;&gt;&lt;a href=&quot;#1-1-演变历史&quot; class=&quot;headerlink&quot; title=&quot;1.1 演变历史&quot;&gt;&lt;/a&gt;1.1 演变历史&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;最早的字体是“帝国大写体”（Imperial Capitals），也被称为“罗马大写体”，古罗马时期字体，用于在石碑上记录重大事件。&lt;/li&gt;
&lt;li&gt;然后是“卡洛林小写体”（Carolingian Minuscule），这种字体在中世纪早期出现，这种字体字间距大，结构清晰简单，但是已经具有了一定的宗教色彩。&lt;/li&gt;
&lt;li&gt;中世纪后期西欧出现了“哥特体”（Gothic），是卡洛林小写体的演化体，这种字体更加复杂和华丽，字间距小，笔画厚重而末端尖锐，具有强烈的宗教色彩。&lt;/li&gt;
&lt;li&gt;“人文主义体”是“文艺复兴之父”彼特拉克提倡发明的字体，受启发于卡洛林小写体字间距大，方便阅读的特点，是文艺复兴早期的字体，风格比较圆润轻松，字轴比较倾斜。&lt;/li&gt;
&lt;li&gt;“意大利斜体”受启发于“人文主义体”，这种字体更加自由畅快，同时由于斜体的特点，可以兼顾辨认和节省空间的特点，是当时印刷业的新宠。&lt;/li&gt;
&lt;li&gt;“印刷罗马体”是活字印刷术发明后在意大利发明的，这种字体受启发于“人文主义体”和“帝国大写体”，这种字体字轴中正，笔画圆润，书写痕迹浅，成为了“人文主义体”的淘汰者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/posts/f0b58a03/image-20240211214139291.png&quot; alt=&quot;image-20240211214139291&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-2-具体介绍&quot;&gt;&lt;a href=&quot;#1-2-具体介绍&quot; class=&quot;headerlink&quot; title=&quot;1.2 具体介绍&quot;&gt;&lt;/a&gt;1.2 具体介绍&lt;/h3&gt;</summary>
    
    
    
    
    <category term="S7课上" scheme="https://thysrael.github.io/tags/S7%E8%AF%BE%E4%B8%8A/"/>
    
    <category term="吃喝玩乐" scheme="https://thysrael.github.io/tags/%E5%90%83%E5%96%9D%E7%8E%A9%E4%B9%90/"/>
    
  </entry>
  
</feed>
