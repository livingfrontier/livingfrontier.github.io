:PROPERTIES:
:ID:       b169b4e7-0291-483c-a3ea-92376e1bf052
:END:
#+title: Mechanism or Policy

Unix 有一个设计哲学是“提供机制（Mechanism）而不是策略（Policy）”。

大部分的编程问题都可以被切割成两个部分：

- 机制：需要提供什么功能
- 策略：怎样实现这些功能

如果将这两个部分分开来看，机制强调的是“只干一件事情并将它干好”，这样保证了可以用较小的精力实现较强的功能（也是 KISS 原则的体现）。

而在策略方面，则是用于利用不同的机制自由组合，最终满足大且复杂的需求，机制的设计不应当侵犯策略的自由度，这就要求机制实现的功能要具有通用性和原子性。

机制就像严丝合缝，小巧玲珑的乐高砖块，策略像是复杂的设计图纸。两者结合起来才是充满美丽的乐高。

这种设计在 [[id:7ba3aeb8-f711-4fc8-aac6-5ef4fb647011][Emacs]] 中也有体现，裸 emacs 是非常难用的，这不是因为 emacs 没有提供足够多的功能。恰恰相反，emacs 提供了非常多的功能性机制，但是却没有提供任何具体的策略，这就需要用户根据自己的需求去组装这些机制，打造最适合自己的编辑器。

但是这种设计思路并非完美，实际上它要求用户具有极高的心智水平，并且付出一定的时间成本才能满足自己的需求，这在很多场景下是不切实际的。

我觉得软件具有 3 个维度：

1. 功能强大
2. 操作简单
3. 自由度高

这三个维度在具体实现中是有冲突的，往往设计中无法全部达到。功能强大和操作简单的软件，只有限制了用户的自由度，才可以利用简单的操作控制强大的软件，比如说 MacOS ； 功能强大和自由度高的软件，一定需要复杂的操作才能完成，比如说 emacs 或者 linux kernel ；操作简单和自由度高的软件，功能一般是比较单一的，比如说许多 POSIX 命令，如 ~ls, grep~ 等。
