:PROPERTIES:
:ID:       3074726d-e51d-438a-b6bc-c5bc26975a53
:END:
#+title: 加密

* 概念
加密（Encrypt）是保证信息在传输过程中安全的一种技术。

设计加密技术时假设通信管道被敌方完全监听，敌方可以截获、伪造和修改传输的信息，加密技术的设计者要保证信息不被敌方解读和伪造。核心技术是 *加密* 。

涉及的概念有：

- message: 信息或者明文，是可以直接被阅读的。
- sceret: 密文，是明文加密后的结果，在没有解密的时候是无法被阅读的。
- key: 密钥，可以将明文加密成密文，也可以将密文解密成明文（并不需要两个功能兼备）。
- channel: 信道，我们默认信道是被敌人监听的，是不安全的。

用代码表达：

#+begin_src c
  secret = encrypt(key, message);
  message = decrypt(key, secret);
#+end_src

也就是如下过程：

#+DOWNLOADED: screenshot @ 2024-03-26 14:32:37
[[file:img/2024-03-26_14-32-37_screenshot.png]]

* 实例
** 情景
假设这样一个情景，A 和 B 想要进行信息的沟通，X 作为攻击者窃取他们的信息。

** 明文
一开始 A 和 B 使用明文沟通，X 可以直接监听信道，这样就可以截获 A 和 B 的明文。

只要 X 监听信道，那么就无法使用明文沟通。X 的这种攻击手段被称为“ *嗅探攻击* ”。

** 对称加密
A 和 B 无法阻止 X 监听信道，所以选择不传递明文信息，而是选择对信息进行[[id:e14f21bc-7085-49a7-a6f1-61e9f03c4523][对称加密]]，在信道中传递密文，这样 X 监听到的都是密文，因为 X 不具被密钥，所以无法解密。

加密其实有两种，之所以 A 和 B 先选择对称加密，是因为对称机密的原理更简单，效率更高，历史悠久。

但是对称加密要求 A 和 B 都持有相同的密钥，因此存在一个密钥的交换问题，A 在制作了密钥需要发给 B 来保证双方密钥一致。但是因为信道被 X 监听，所以 X 也拿到了本该发给 B 的密钥，所以 X 又可以解密密文了。

因为密钥交换的问题，A 和 B 无法使用对称加密沟通。

** 密钥交换算法 or 非对称加密
A 和 B 不能在被 X 监听的信道直接传递密钥。A 和 B 这个时候有两个选择：

1. 使用[[id:c4754b41-aa9b-4600-9086-b4bf2bd751a3][密钥交换算法]] ，这个一个数学算法，可以保证在被监听的信道上可靠得传递对称加密的密钥
2. 使用[[id:0f7e3160-d9b1-4ae7-a0d3-5edfa0c5ef76][非对称加密]] ，这是一种新型加密技术，这种技术的特性不介意信道中的密钥被监听

非对称加密这种技术又有两种使用方法：

1. 用非对称加密来传递对称加密的密钥，然后使用对称加密通信
2. 直接用非对称加密通信 

具体选择哪种方法要根据具体情景判断，因为非对称加密技术的性能不如对称加密好。

无论 A 和 B 选择了哪种方式，总之 X 现在没法窃取密钥了，A 和 B 现在可以安全地发密文沟通了。

但是 X 选择假装成 B 和 A 通信，发一些干扰信息，比如如“上次的密钥我忘了，再发一份呗”，“明天下午 3 点广场见”的干扰密文，A 并不能辨别这到底是 B 发的，还是 X 发的，导致犯错误，比如说直接交出密钥，或者作出错误行为。

为什么 X 可以伪造密文？在非对称加密中，公钥是在不安全信道中传播的，所以 X 可以利用公钥给 A 发送密文。

而如果使用密钥交换算法，我不太清楚有没有办法使用手段正面攻破。但是 X 至少可以做到，截获 B 的密文并在其他时间转发给 A ，来干扰 A 的行为。比如说 B 在星期一说“明天见”，X 就截获后在星期二再发给 A ，这样 A 就以为两人的碰头时间在星期三而不是星期二。

此外，如果 A 和 B 采用了非对称加密通信，那么 X 就还有一种攻击手段。那就是在 A 给 B 传递公钥的时候，截获了这个公钥，再把自己的公钥发给 B ，这样 B 就以为 X 是 A 了。

X 的这种攻击手段被称为“ *中间人攻击* ”，现在 A 和 B 因为无法区分密文的来源而束手无策。

** 数字证书
为了确定密钥的来源，A 和 B 采用了[[id:e5e4091c-4689-436c-a8f8-c764c1efaba5][数字证书]]技术，这种技术利用了一个完全可信的第三方公钥，保证了 A 和 B 密文来源的可信性。

至此，X 已经没有办法伪造密文了，但是 X 还有办法，因为篡改密文的难度要低于破译密文，X 可以直接篡改 B 的密文，比如说 B 说“星期二 13”，X 就抹去最后的“3”，这样 A 就以为是在星期二的 1 点见面了。

现在 A 和 B 虽然可以收到彼此的密文，但是无法确定密文是否被篡改，也就是无法保证密文的完整性。

** 数字签名
为了保证密文完整性，A 和 B 采用了[[id:41571ac8-c055-4744-a67e-39a044622828][数字签名]]技术，这种技术会在加密明文的同时加密明文的摘要（摘要就是根据明文生成的一个哈希），这样如果 X 直接篡改明文，就会导致明文和摘要不匹配。

签名技术依赖的是“只有相同的明文才会生成相同的摘要”这个特性，所以一旦明文发生变化，那么新生成的摘要就一定会和原本的摘要不符。重新生成摘要并与原本的摘要进行对比的这个过程被叫做“认证（Authenticate）”。有的语境下签名就是摘要。

至此，大概 A 和 B 就可以安全的通信了。但是事情还没有结束，现代公钥体系（也就是在不可信信道中传播的密钥）都依赖于某些数学问题的难以求解性，这些问题以目前的电子计算机的理论来看，是无法破解的（或者是破解要几亿年）。但是在量子计算机上，这些问题的破解难度很小，也就是所谓的 *量子不安全* （quantum-unsafe）的。

所以可能再过一些日子，A 和 B 就又不能安全通信了。

** 量子安全
为了应对 X 的量子计算机破解法，A 和 B 使用了[[id:bf65898e-6698-4690-9103-58503a6c70f8][量子安全]] 。
